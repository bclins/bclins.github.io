<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Theory of Computing</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://bclins.github.io/mockup.css" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
  :root {
    --header-color: #000; 
    --link-color: #00e; 


  }

  body {
    text-align: left;
  } 
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Theory of Computing</h1>
</header>
<h2 id="computer-science-461---spring-2025">Computer Science 461 -
Spring 2025</h2>
<center>
Jump to: <a href="index.html">CS 461 Homepage</a>, <a
href="#week-1-notes">Week 1</a>, <a href="#week-2-notes">Week 2</a>, <a
href="#week-3-notes">Week 3</a>, <a href="#week-4-notes">Week 4</a>, <a
href="#week-5-notes">Week 5</a>, <a href="#week-6-notes">Week 6</a>, <a
href="#week-7-notes">Week 7</a>, <a href="#week-8-notes">Week 8</a>, <a
href="#week-9-notes">Week 9</a>, <a href="#week-10-notes">Week 10</a>,
<a href="#week-11-notes">Week 11</a>, <a href="#week-12-notes">Week
12</a>, <a href="#week-13-notes">Week 13</a>, <a
href="#week-14-notes">Week 14</a>
</center>
<h3 id="week-1-notes">Week 1 Notes</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Jan 13</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=15">1.3</a></td>
<td style="text-align: left;">Proof techniques</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Jan 15</td>
<td style="text-align: center;"><a
href="https://introtcs.org/public/lec_02_representation.html#defining-representations">2.1
- 2.2</a></td>
<td style="text-align: left;">Notation &amp; encodings</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Jan 17</td>
<td style="text-align: center;"><a
href="https://introtcs.org/public/lec_03_computation.html#defining-computation">3.1
- 3.7</a></td>
<td style="text-align: left;">Boolean circuits</td>
</tr>
</tbody>
</table>
<h4 id="mon-jan-13">Mon, Jan 13</h4>
<p>Today we talked about proof techniques, particularly proof by
induction. We looked at these two examples:</p>
<ol type="1">
<li>Prove that if a set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
elements, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>
subsets.</li>
</ol>
<p>The second example had to do with the famous <strong>Tower’s of Hanoi
puzzle</strong>( see <a href="https://youtu.be/SMleU0oeGLg"
class="uri">https://youtu.be/SMleU0oeGLg</a>).</p>
<ol start="2" type="1">
<li>Use induction to prove that it is always possible to move the disks
from one peg to another by moving one disk at a time without breaking
the rules.</li>
</ol>
<p>You can also translate many induction arguments into recursive
algorithms.</p>
<ol start="3" type="1">
<li><p>Write a Python function <code>sublists(A)</code> that inputs a
list <code>A</code> and returns a list containing every sublist of
<code>A</code>.</p>
<details>
<p>We did this in class and we came up with something like this:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a> <span class="kw">def</span> sublists(A):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="bu">len</span>(A) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span> [A]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>     last <span class="op">=</span> A[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     B <span class="op">=</span> A[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>     sublists_without_last <span class="op">=</span> sublists(other_elements)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>     sublists_with_last <span class="op">=</span> [s <span class="op">+</span> [last] <span class="cf">for</span> s <span class="kw">in</span> sublists_without_last]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> sublists_without_last <span class="op">+</span> sublists_with_last</span></code></pre></div>
</details></li>
<li><p>Suppose you have three stack variables (implemented as Python
lists):</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>stack1 <span class="op">=</span> [<span class="dv">10</span> <span class="op">-</span> k <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>)]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>stack2 <span class="op">=</span> []</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>stack3 <span class="op">=</span> []</span></code></pre></div>
<p>Write a function
<code>move_disks(n, start_stack, temp_stack, final_stack)</code> that
recursively moves n disks from the <code>start_stack</code> to the
<code>final stack</code>.</p></li>
</ol>
<h4 id="wed-jan-15">Wed, Jan 15</h4>
<p>Today we reviewed mathematical notation, including some new notation
we will be using. We defined <strong>alphabets</strong> which are sets
of symbols we can use to represent things. The most common alphabet in
computer science is the binary alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\Sigma = \{0, 1\}</annotation></semantics></math>.
We use the notation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Σ</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math>
to denote the set of all possible finite length strings constructed from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>.</p>
<p>A set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
can be <strong>represented</strong> or <strong>encoded</strong> using an
alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
if there is a 1-to-1 function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>:</mo><mi>S</mi><mo>→</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">E: S \rightarrow \Sigma^*</annotation></semantics></math>.</p>
<div class="Theorem">
<p><strong>Theorem.</strong> Any countable set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
can be encoded with a 1-to-1 function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>:</mo><mi>S</mi><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">E:S \rightarrow \{0,1\}^*</annotation></semantics></math>.</p>
</div>
<p>We discussed specific encodings such as how to encode the integers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℤ</mi><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math>
and the rationals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℚ</mi><annotation encoding="application/x-tex">\mathbb{Q}</annotation></semantics></math>.</p>
<ul>
<li><strong>Example:</strong> <a
href="https://upload.wikimedia.org/wikipedia/commons/d/dd/ASCII-Table.svg">ASCII
characters</a></li>
</ul>
<p>We also observed another fact:</p>
<div class="Theorem">
<p><strong>Theorem.</strong> If we can encode a set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>,
then we can encode tuples in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>.</p>
</div>
<p>At the end we considered the set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>∞</mi></msup><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>f</mi><mo>:</mo><mi>f</mi><mo>:</mo><mi>ℕ</mi><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{0,1\}^\infty = \{f : f : \mathbb{N}\rightarrow \{0,1\} \}</annotation></semantics></math>
which you can think of as the set of all infinitely long strings of
zeros and ones. We finished by proving</p>
<div class="Theorem">
<p><strong>Theorem.</strong> There is no one-to-one function from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>∞</mi></msup></mrow><annotation encoding="application/x-tex">\{0,1\}^\infty</annotation></semantics></math>
into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">\{0,1\}^*</annotation></semantics></math>.
<!--*--></p>
</div>
<p>A corollary of this theorem is that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>∞</mi></msup></mrow><annotation encoding="application/x-tex">\{0,1\}^\infty</annotation></semantics></math>
is uncountable.</p>
<h4 id="fri-jan-17">Fri, Jan 17</h4>
<p>We talked about <strong>Boolean circuits</strong> which are formed by
AND, OR, and NOT gates. These can be used to implement any
<strong>Boolean expression</strong> formed by the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo><annotation encoding="application/x-tex">\wedge</annotation></semantics></math>
(AND),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∨</mo><annotation encoding="application/x-tex">\vee</annotation></semantics></math>
(OR), and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>¬</mo><annotation encoding="application/x-tex">\neg</annotation></semantics></math>
(NOT) operators.</p>
<center>
<figure>
<img src="https://imgs.xkcd.com/comics/logic_gates.png"></img>
<figcaption>
<a href="https://xkcd.com/2497/">XKCD 2497</a>
</figcaption>
</figure>
</center>
<ol type="1">
<li><p>Write a Boolean expression that takes three Boolean inputs,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x, y, z</annotation></semantics></math>
and returns <code>true</code> if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x, y, z</annotation></semantics></math>
are all the same, and <code>false</code> otherwise.</p></li>
<li><p>Show that you can construct the function IF x THEN y ELSE z for
any Boolean inputs x, y, z using AND, OR, and NOT gates.</p>
<details>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>∧</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∨</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>¬</mo><mi>x</mi><mo>∧</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(x \wedge y) \vee (\neg x \wedge z)</annotation></semantics></math></p>
</details></li>
<li><p>Use mathematical induction (and the previous result) to prove the
following:</p></li>
</ol>
<div class="Theorem">
<p><strong>Theorem.</strong> Every function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>n</mi></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f:\{0,1\}^n \rightarrow \{0,1\}</annotation></semantics></math>
can be represented by a Boolean circuit.</p>
</div>
<p>We say that the Boolean operations
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo><annotation encoding="application/x-tex">\wedge</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∨</mo><annotation encoding="application/x-tex">\vee</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>¬</mo><annotation encoding="application/x-tex">\neg</annotation></semantics></math>)
are a <strong>universal set of operations</strong> since every Boolean
function on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\{0,1\}^n</annotation></semantics></math>
can be constructed using those operations.</p>
<p>We finished by talking about how the NAND operation is universal all
by itself. Using just NAND gates, you can construct any Boolean function
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\{0,1\}^n</annotation></semantics></math>.</p>
<div class="Theorem">
<p><strong>Theorem.</strong> Every function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>n</mi></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f:\{0,1\}^n \rightarrow \{0,1\}</annotation></semantics></math>
can be represented using NAND operations.</p>
</div>
<ol start="4" type="1">
<li><p>Show that you can use a NAND gate to implement a NOT
gate.</p></li>
<li><p>Show that you can use two NAND gates to implement an AND
gate.</p></li>
<li><p>Use a truth table to confirm that
<code>(NOT x) NAND (NOT y)</code> is equivalent to
<code>x OR y</code>.</p></li>
</ol>
<h3 id="week-2-notes">Week 2 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Jan 20</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">MLK day, no class</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Jan 22</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">Impossible computer programs</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Jan 24</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=29">2.1</a></td>
<td style="text-align: left;">Intro to finite automata</td>
</tr>
</tbody>
</table>
<h4 id="wed-jan-22">Wed, Jan 22</h4>
<ul>
<li><strong>Slides:</strong> <a href="day4.html">Impossible
programs</a></li>
</ul>
<h4 id="fri-jan-24">Fri, Jan 24</h4>
<p>Last time we saw that some functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f: \{0,1\}^* \rightarrow \{0,1\}</annotation></semantics></math>
cannot be computed by a computer program. We saw two proofs that seemed
very different. One used a cardinality argument and the other used proof
by contradiction to show that the program
<code>check_if_program_returns_one()</code> is impossible. It turns out
that both proofs are actually closely related.</p>
<p>Suppose we make a list of all possible programs on the left column of
an infinite table, with a list of all possible input strings at the top
of the table. The values in the body of the table are the output of each
program on each input (including the possibility that there is no
output). The table might look like this:</p>
<center>
<table class="bordered">
<tr>
<th>
</th>
<th>
Input 1
</th>
<th>
Input 2
</th>
<th>
Input 3
</th>
<th>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\ldots</annotation></semantics></math>
</th>
</tr>
<tr>
<th>
Program 1
</th>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\ldots</annotation></semantics></math>
</td>
</tr>
<tr>
<th>
Program 2
</th>
<td>
0
</td>
<td>
0
</td>
<td>
na
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\ldots</annotation></semantics></math>
</td>
</tr>
<tr>
<th>
Program 3
</th>
<td>
0
</td>
<td>
na
</td>
<td>
1
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\ldots</annotation></semantics></math>
</td>
</tr>
<tr>
<th>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⋮</mi><annotation encoding="application/x-tex">\vdots</annotation></semantics></math>
</th>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⋮</mi><annotation encoding="application/x-tex">\vdots</annotation></semantics></math>
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⋮</mi><annotation encoding="application/x-tex">\vdots</annotation></semantics></math>
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⋮</mi><annotation encoding="application/x-tex">\vdots</annotation></semantics></math>
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋱</mo><annotation encoding="application/x-tex">\ddots</annotation></semantics></math>
</td>
</tr>
</table>
</center>
<p>We can construct a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f:\{0,1\}^* \rightarrow \{0,1\}</annotation></semantics></math>
that cannot correspond to any program by using the same diagonalization
argument that proves that there are uncountably many infinite binary
sequences. That’s essentially what we did when we tried to construct the
function <code>check_if_program_returns_one()</code> last time. We
created a function <code>reverse_check()</code> that corresponds to
reversing the values on the main diagonal of the table above. So we were
using a <strong>diagonalization</strong> argument, which is the same
argument used to prove that there are uncountably many functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f:\{0,1\}^* \rightarrow \{0,1\}</annotation></semantics></math>.</p>
<p>After that, we introduced finite automata. We started with this
example: An automatic door at a grocery store has sensors on the front
and rear. It opens if the sensor on the front is active. It won’t close
until neither of the sensors are active. You can model this with the
following <strong>state diagram</strong>:</p>
<center>
<img src="AutomaticDoorDFA.png" width = 360></img>
</center>
<p>This is an example of a <strong>finite state machine</strong>, also
known as a <strong>deterministic finite automata (DFA)</strong>.</p>
<div class="Theorem">
<p><strong>Definition.</strong> A <strong>deterministic finite automata
(DFA)</strong> consists of</p>
<ol type="1">
<li>A finite set of <strong>states</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>.</li>
<li>A finite <strong>alphabet</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
of possible input signals.</li>
<li>A <strong>transition function</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi>Σ</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">\delta: Q \times \Sigma \rightarrow Q</annotation></semantics></math>.</li>
<li>An <strong>initial</strong> or <strong>start state</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0 \in Q</annotation></semantics></math>.</li>
<li>A set of <strong>final</strong> or <strong>accepting states</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">F \subseteq Q</annotation></semantics></math>.<br />
</li>
</ol>
</div>
<ol type="1">
<li><p>What are the sets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
for the automatic door example above?</p></li>
<li><p>Make a table showing the values of the transition function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>
for the automatic door.</p></li>
<li><p>An automatic toll booth accepts nickles, dimes, and quarters. The
gate won’t open until it receives 25 cents. Draw a state diagram for the
toll booth. What are the sets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>?</p></li>
<li><p>A combination lock (like the ones at the campus post office) can
be modeled as a finite state machine. What are the states and what are
the input signals?</p></li>
<li><p>Describe a DFA that can compute the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f: \{0,1\}^* \rightarrow \{0,1\}</annotation></semantics></math>
which returns 1 when the input string has an odd number of 1’s and 0
otherwise.</p></li>
</ol>
<h3 id="week-3-notes">Week 3 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Jan 27</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=31">2.2</a>
- <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=39">2.3</a></td>
<td style="text-align: left;">Regular languages</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Jan 29</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=43">2.4</a></td>
<td style="text-align: left;">Nondeterministic finite automata</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Jan 31</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=56">2.6</a></td>
<td style="text-align: left;">NFAs and regular languages</td>
</tr>
</tbody>
</table>
<h4 id="mon-jan-27">Mon, Jan 27</h4>
<p>Today we started with these questions about DFAs:</p>
<ol type="1">
<li>For the DFA shown below:
<center>
<img
src="https://people.hsc.edu/faculty-staff/blins/classes/fall23/coms461/FiniteAutomata1.png" />
</center>
<ol type="a">
<li>What is the transition function?</li>
<li>Describe the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f:\{0,1\}^* \rightarrow \{0,1\}</annotation></semantics></math>
that this DFA computes.</li>
</ol></li>
<li>Draw the state diagram for a DFA that computes whether a binary
string contains 011.</li>
</ol>
<div class="Theorem">
<p><strong>Definition.</strong> For any finite alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>,
a <strong>language</strong> is a subset of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Σ</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math>.
A language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>
is <strong>regular</strong> if there is a DFA
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>:</mo><mi>M</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> accepts </mtext><mspace width="0.333em"></mspace></mrow><mi>w</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{w \in \Sigma^* : M \text{ accepts } w \}</annotation></semantics></math>.</p>
</div>
<p>Conceptually, when we think about a DFA, we understand that it can do
two things:</p>
<ul>
<li>A DFA can compute a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f:\Sigma^* \rightarrow \{0,1\}</annotation></semantics></math>.</li>
<li>A DFA can recognize a language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>.</li>
</ul>
<p>It’s important to understand that these two interpretations of what a
DFA does are equivalent, because there is a simple bijection between the
set of all possible languages (the power set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><msup><mi>Σ</mi><mo>*</mo></msup></msup><annotation encoding="application/x-tex">2^{\Sigma^*}</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Σ</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math>)
and the set of all possible functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f: \Sigma^* \rightarrow \{0,1\}</annotation></semantics></math>.</p>
<ol start="3" type="1">
<li>Construct a bijection from the power set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><msup><mi>Σ</mi><mo>*</mo></msup></msup><annotation encoding="application/x-tex">2^{\Sigma^*}</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>f</mi><mo>:</mo><mi>f</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{f: f: \Sigma^* \rightarrow \{0,1\}\}</annotation></semantics></math>.</li>
</ol>
<p>Our solution ended up involving the <strong>indicator
function</strong> for a set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>,
where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>L</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>w</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mn>1</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mi>w</mi><mo>∈</mo><mi>L</mi><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>0</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> otherwise.</mtext></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f_L(w) = \begin{cases} 1 &amp; \text{ if } w \in L, \\ 0 &amp; \text{ otherwise.} \end{cases}</annotation></semantics></math></p>
<h4 id="wed-jan-29">Wed, Jan 29</h4>
<p>We started by constructing some more examples of DFAs.</p>
<ol type="1">
<li><p>Find a DFA that computes whether a binary string <em>ends
with</em> 011. (This is similar, but not the same as a DFA we
constructed last time).</p></li>
<li><p>How many states would a DFA need if you wanted to check whether a
binary string has a 1 in the third position from the last?</p></li>
</ol>
<p>Then we talked about these properties of regular languages.</p>
<div class="Theorem">
<p><strong>Theorem (Finite languages are regular).</strong> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
is a finite alphabet, then any finite
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊂</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subset \Sigma^*</annotation></semantics></math>
is a regular language.</p>
</div>
<ol start="3" type="1">
<li>How would you prove this? If I give you a finite set of strings
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>,
how could you turn that into a DFA that recognizes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>?</li>
</ol>
<div class="Theorem">
<p><strong>Theorem (Closure properties of regular languages).</strong>
Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">A, B \subseteq \Sigma^*</annotation></semantics></math>
be regular languages. Then</p>
<ul>
<li>The <strong>union</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math>
is a regular language.</li>
<li>The <strong>concatenation</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∘</mo><mi>B</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mi>b</mi><mo>:</mo><mi>a</mi><mo>∈</mo><mi>A</mi><mo>,</mo><mi>b</mi><mo>∈</mo><mi>B</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A \circ B = \{ab : a \in A, b \in B\}</annotation></semantics></math>
is a regular language.<br />
</li>
<li>The <strong>Kleene-star</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>*</mo></msup><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi>…</mi><msub><mi>a</mi><mi>k</mi></msub><mo>:</mo><mi>k</mi><mo>≥</mo><mn>0</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and each </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>a</mi><mi>i</mi></msub><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A^* = \{a_1 a_2 \ldots a_k : k \ge 0 \text{ and each } a_i \in A \}</annotation></semantics></math>
is a regular language.</li>
</ul>
<p>We say that the set of regular languages over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
is <strong>closed</strong> under the three operations: union,
concatentation, and Kleene-star.</p>
</div>
<ol start="4" type="1">
<li>Suppose that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mtext mathvariant="normal">big</mtext><mo>,</mo><mtext mathvariant="normal">small</mtext><mo>,</mo><mtext mathvariant="normal">pet</mtext><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A = \{ \text{big}, \text{small}, \text{pet} \}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mtext mathvariant="normal">cat</mtext><mo>,</mo><mtext mathvariant="normal">dog</mtext><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">B = \{ \text{cat}, \text{dog} \}</annotation></semantics></math>.
What are the elements of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∘</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \circ B</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>B</mi><mo>*</mo></msup><annotation encoding="application/x-tex">B^*</annotation></semantics></math>?</li>
</ol>
<p>We proved the first part of the theorem above (regular languages are
closed under unions) in class by thinking about how to construct a new
DFA
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
that accepts
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math>
using DFAs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>A</mi></msub><annotation encoding="application/x-tex">M_A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>B</mi></msub><annotation encoding="application/x-tex">M_B</annotation></semantics></math>
that accept
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
respectively. To prove this, we answered these questions:</p>
<ol type="1">
<li><p>If the machine
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
is built by running both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>A</mi></msub><annotation encoding="application/x-tex">M_A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>B</mi></msub><annotation encoding="application/x-tex">M_B</annotation></semantics></math>
simultaneously, what are the possible states of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>?</p></li>
<li><p>What are the initial states for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>?</p></li>
<li><p>What is the transition function for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>?</p></li>
<li><p>What are the accepting states of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>?</p></li>
</ol>
<h4 id="fri-jan-31">Fri, Jan 31</h4>
<ol type="1">
<li><p>We started by asking whether regular languages are closed under
intersections. Can we adapt the proof we gave last time for unions to
intersections?</p>
<details>
<p>Yes, regularly languages are closed under intersections. The proof is
almost exactly the same as the proof for unions, the only difference is
that the DFA to recognize
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∩</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cap B</annotation></semantics></math>
has final states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>A</mi></msub><mo>×</mo><msub><mi>F</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">F_A \times F_B</annotation></semantics></math>
while the DFA to recognize
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math>
has final states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mi>A</mi></msub><mo>×</mo><msub><mi>Q</mi><mi>B</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Q</mi><mi>A</mi></msub><mo>×</mo><msub><mi>F</mi><mi>B</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(F_A \times Q_B) \cup (Q_A \times F_B)</annotation></semantics></math>,
that is, any pair of states from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mi>A</mi></msub><mo>×</mo><msub><mi>Q</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">Q_A \times Q_B</annotation></semantics></math>
where at least one of the two is final.</p>
</details></li>
</ol>
<p>To prove that regular languages are closed under concatenation, we
introduced a new idea: <strong>non-deterministic finite automata
(NFAs)</strong>.</p>
<p>We looked at this example:</p>
<center>
<img
src="https://people.hsc.edu/faculty-staff/blins/classes/fall23/coms461/NFA1.png" />
</center>
<p>An NFA can have more than one arrow exiting a state with the same
input. When that happens, the machine splits into multiple copies, one
for each possible next state.</p>
<p>If an NFA enters a state that has exiting arrows labeled with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math>,
then the NFA immediately splits into multiple copies, one where the
current state stays the same, and one where the current state moves
along each branch labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math>.
This can happen several times, if there is a sequence of branches
labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math>.</p>
<p>If there is no arrow leaving a state for a given input signal, that
means that the current copy of the machine is a dead end and it does not
need to be continued.</p>
<p>The NFA accepts a string if any of the parallel computations is in an
accepting state after the string is read. We answered these
questions:</p>
<ol start="2" type="1">
<li><p>Which states are active at each step as we read the input string
01010?</p></li>
<li><p>Does this NFA accept the string 01010?</p></li>
<li><p>Describe the set of all strings in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">\{0,1\}^*</annotation></semantics></math>
<!--*--> that this NFA will accept.</p></li>
</ol>
<p>Here is the technical definition of an NFA.</p>
<div class="Theorem">
<p><strong>Definition.</strong> A <strong>non-deterministic finite
automata (NFA)</strong> consists of</p>
<ol type="1">
<li>A finite set of <strong>states</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>.</li>
<li>A finite <strong>alphabet</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
of possible input signals.</li>
<li>A <strong>transition function</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi>Σ</mi><mo>→</mo><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">\delta: Q \times \Sigma \rightarrow 2^Q</annotation></semantics></math>.</li>
<li>An <strong>initial</strong> or <strong>start state</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0 \in Q</annotation></semantics></math>.</li>
<li>A set of <strong>final</strong> or <strong>accepting states</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">F \subseteq Q</annotation></semantics></math>.<br />
</li>
</ol>
</div>
<p>The only change from the definition of a DFA is that the transition
function for an NFA can return a <em>set of states</em> at each step
(including, possibly, the empty set). Think of these multivalued
transitions as creating multiple branching computations that run in
parallel. If the transition function returns the empty set, that means
that that branch of the parallel computation is a dead end and does not
continue.</p>
<ol start="5" type="1">
<li><p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">A, B \subseteq \Sigma^*</annotation></semantics></math>
be regular languages recognized by DFAs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>A</mi></msub><annotation encoding="application/x-tex">M_A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>B</mi></msub><annotation encoding="application/x-tex">M_B</annotation></semantics></math>
respectively. Describe an NFA that uses the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>A</mi></msub><annotation encoding="application/x-tex">M_A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>B</mi></msub><annotation encoding="application/x-tex">M_B</annotation></semantics></math>
to check if a string is in the union
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math>.
Note that every DFA is an NFA that has a transition function that only
ever returns a single state at a time.</p></li>
<li><p>Describe an NFA that can check whether or not the 3rd to last
digit of a binary string is 1 using fewer states than the DFA we
described last time. Hint: What if the NFA “guesses” every time it sees
a 1 that that might be the third to last entry. What should it’s states
be from that point on?</p></li>
</ol>
<h3 id="week-4-notes">Week 4 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Feb 3</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=49">2.5</a></td>
<td style="text-align: left;">NFAs and DFAs are equivalent</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Feb 5</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=60">2.7</a></td>
<td style="text-align: left;">Regular expressions</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Feb 7</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=68">2.8</a></td>
<td style="text-align: left;">Regular expressions and languages</td>
</tr>
</tbody>
</table>
<h4 id="mon-feb-3">Mon, Feb 3</h4>
<p>Today we continued talking about NFAs. We’ve been following the <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf">textbook
by Meshwari &amp; Smid</a> pretty closely this week, so I recommend
reading skimming <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=56">Section
2.6</a> which is what we covered today.</p>
<!--1. Construct an NFA that accepts a string in $\{0\}^*$ iff the length of the string is a multiple of 2 or 3.  Can you construct a DFA that does the same thing and with the same number of states? -->
<ol type="1">
<li><p>We described an NFA that recognizes the concatentation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math>
of two regular languages by running DFAs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>A</mi></msub><annotation encoding="application/x-tex">M_A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>B</mi></msub><annotation encoding="application/x-tex">M_B</annotation></semantics></math>
in parallel. We answer these questions about the NFA:</p>
<ol type="a">
<li>What are the states of the NFA?</li>
<li>What are the final states of the NFA?</li>
</ol></li>
<li><p>We also described an NFA that recognizes the Kleene star
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>A</mi><mo>*</mo></msup><annotation encoding="application/x-tex">A^*</annotation></semantics></math>
of a regular language. The idea is similar to the previous construction,
but you need a way to accept the empty string (if it isn’t part of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>).</p></li>
</ol>
<p>To complete the proof that regular languages are closed under these
two operations, we need to prove this:</p>
<div class="Theorem">
<p><strong>Theorem (Equivalence of NFAs and DFAs).</strong> If there is
an NFA that recognizes a language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">A \subseteq \Sigma^*</annotation></semantics></math>,
then there is a DFA that also recognizes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p>
</div>
<p>The proof is surprisingly simple. An NFA with states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>,
transition function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi>Σ</mi><mo>→</mo><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">\delta: Q \times \Sigma \rightarrow 2^Q</annotation></semantics></math>
can be turned into a DFA that has states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>Q</mi></msup><annotation encoding="application/x-tex">2^Q</annotation></semantics></math>
and transition function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>2</mn></msub><mo>:</mo><msup><mn>2</mn><mi>Q</mi></msup><mo>×</mo><mi>Σ</mi><mo>→</mo><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">\delta_2: 2^Q \times \Sigma \rightarrow 2^Q</annotation></semantics></math>.</p>
<ol start="3" type="1">
<li><p>Describe specifically what
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mo>,</mo><mi>σ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\delta_2(S, \sigma)</annotation></semantics></math>
returns for any subset
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">S \subseteq Q</annotation></semantics></math>
using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>.</p></li>
<li><p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
denotes the accepting states of the NFA, then what are the corresponding
accepting states of the DFA?</p></li>
<li><p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q \in Q</annotation></semantics></math>
is the initial state of the NFA, what is the initial state of the
DFA?</p></li>
</ol>
<p>We applied the idea of this proof to <a
href="HW/HW3.pdf#page=2">Exercise 5 from Homework 3</a>.</p>
<h4 id="wed-feb-5">Wed, Feb 5</h4>
<p>We introduced <strong>regular expressions</strong> (regex).</p>
<div class="Theorem">
<p><strong>Definition.</strong> A <strong>regular expression</strong>
over an alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
is a string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math>
with symbols from the extended alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mspace width="0.222em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mspace width="0.222em"></mspace><mo>,</mo><mspace width="0.222em"></mspace><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.222em"></mspace><mo>,</mo><mspace width="0.222em"></mspace><mo>*</mo><mspace width="0.222em"></mspace><mo>,</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\Sigma \cup \{ ~(~ , ~)~ , ~*~ , ~|~ \}</annotation></semantics></math>
that has one of the following forms:</p>
<ol type="1">
<li>A <strong>symbol</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>∈</mo><mi>Σ</mi></mrow><annotation encoding="application/x-tex">e \in \Sigma</annotation></semantics></math>
is a regular expression.</li>
<li>A <strong>concatenation</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e = e_1e_2</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>2</mn></msub><annotation encoding="application/x-tex">e_2</annotation></semantics></math>
are regular expressions.</li>
<li>A <strong>union</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><msub><mi>e</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e = e_1|e_2</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>2</mn></msub><annotation encoding="application/x-tex">e_2</annotation></semantics></math>
are regular expressions.</li>
<li>A <strong>grouping</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">e = (e_1)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
is a regular expression.</li>
<li>A <strong>star</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><msub><mi>e</mi><mn>1</mn></msub><mo>*</mo></mrow><annotation encoding="application/x-tex">e = e_1*</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
is either a single symbol or grouping.</li>
</ol>
<p>We also accept the empty set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⌀</mi><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math>
and the empty string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math>
as regular expressions.</p>
</div>
<p>Regular expressions are used to match sets of strings (i.e.,
languages over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>).</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e_1e_2</annotation></semantics></math>
matches any concatenation of a string matched by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
with a string matched by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>2</mn></msub><annotation encoding="application/x-tex">e_2</annotation></semantics></math>.<br />
</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e_1|e_2</annotation></semantics></math>
matches anything matched by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>2</mn></msub><annotation encoding="application/x-tex">e_2</annotation></semantics></math>.<br />
</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>*</mo></mrow><annotation encoding="application/x-tex">e_1*</annotation></semantics></math>
matches any finite concatenation of strings that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
matches (including zero matches).</li>
</ul>
<ol type="1">
<li><p>Describe what the following regular expressions represent:</p>
<ol type="a">
<li><code>(0|1)0*</code></li>
<li><code>Σ*1Σ*</code></li>
<li><code>(0|1)*</code></li>
</ol></li>
<li><p>Write a regular expression that recognizes the base-10 decimal
form of any integer that is a multiple of 5.</p></li>
</ol>
<p>Most programming languages use <a
href="https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions">Perl
compatible regular expressions</a> which have several additional
features to make it easier to work with regular expressions. Here are
some examples we talked about in class.</p>
<center>
<table class="bordered">
<tr>
<th colspan="2">
Special Symbols
</th>
</tr>
<tr>
<td>
<code>\s</code>
</td>
<td>
whitespace (tabs, spaces, etc.)
</td>
</tr>
<tr>
<td>
<code>\w</code>
</td>
<td>
alphanumeric (letters &amp; digits)
</td>
</tr>
<tr>
<td>
<code>\d</code>
</td>
<td>
digits (0-9)
</td>
</tr>
<tr>
<td>
<code>.</code>
</td>
<td>
wildcard matches any single character
</td>
</tr>
<tr>
<td>
<code>\</code>
</td>
<td>
escape (for special characters)
</td>
</tr>
</table>
<table>
<tr>
<td>
<table class="bordered">
<tr>
<th colspan="2">
Extra Operators
</th>
</tr>
<tr>
<td>
<code>(e)+</code>
</td>
<td>
at least one
</td>
</tr>
<tr>
<td>
<code>(e)?</code>
</td>
<td>
maybe one (0 or 1)
</td>
</tr>
</table>
</td>
<td>
<table class="bordered">
<tr>
<th colspan="2">
Square Brackets
</th>
</tr>
<tr>
<td colspan="2">
Can match one or more ranges of characters
</td>
</tr>
<tr>
<td>
<code>[a-z]</code>
</td>
<td>
any lower case letter
</td>
</tr>
<tr>
<td>
<code>[a-zA-Z]</code>
</td>
<td>
any letter
</td>
</tr>
<tr>
<td>
<code>[^a-z]</code>
</td>
<td>
anything except a-z
</td>
</tr>
</table>
</td>
</tr>
</table>
</center>
<p>Here is a simple Python regex example:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">&quot;My pet dog likes to go to the park.&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>expr <span class="op">=</span> <span class="st">&quot;pet\s(dog|cat|bird)&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>match <span class="op">=</span> re.search(expr, s)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(match)</span></code></pre></div>
<ol start="3" type="1">
<li><p>Write a regular expression that would match any e-mail address of
the form <code>name@domain.extension</code>.</p></li>
<li><p>Find a regular expression over the alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\Sigma = \{0,1\}</annotation></semantics></math>
that matches all strings that start with a 1, end with a 1, and have an
even number of zeros between.</p></li>
</ol>
<p>We stated, but did not prove the following theorem.</p>
<div class="Theorem">
<p><strong>Theorem (Equivalence of regular expressions and regular
languages).</strong> A language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>Σ</mi></mrow><annotation encoding="application/x-tex">A \subseteq \Sigma</annotation></semantics></math>
is regular if and only if there is a regular expression that describes
it.</p>
</div>
<ol start="5" type="1">
<li>Find an NFA that recognizes the same language as the regular
expression <code>(ab|a)*</code>. Use the ideas from the previous classes
about how to build NFAs to find the union, concatenation, and Kleene
star of languages.</li>
</ol>
<h4 id="fri-feb-7">Fri, Feb 7</h4>
<p>Today we talked about the proof of the theorem from last time that
regular languages and regular expressions are equivalent. One direction
is easy: every language described by a regular expression is regular.
This is because we already know that regular languages are closed under
the union, concatenation, and Kleene-star operations and we also know
that any finite set of strings is a regular language.</p>
<p>Therefore, we should be able to solve this example, which we didn’t
have time for on Wednesday.</p>
<ol type="1">
<li>Find an NFA that recognizes the same language as the regular
expression <code>(ab|a)*</code>. Use the ideas from the previous classes
about how to build NFAs to find the union, concatenation, and Kleene
star of languages.</li>
</ol>
<p>To prove the converse, we described an algorithm for converting NFAs
to regular expressions. Note that the Maheshwwari &amp; Smid textbook
describes a different approach to convert an NFA into a regular
expression in <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=68">Section
2.8</a>. Our approach is to use a generalized NFA:</p>
<div class="Theorem">
<p><strong>Definition.</strong> A <strong>generalized non-deterministic
finite automata</strong> (GNFA) is just like an NFA, except for the
following changes:</p>
<ol type="1">
<li><p>There is only one accept state and it is not the start
state.</p></li>
<li><p>No transitions enter the start state or leave the accept
state.</p></li>
<li><p>Transitions can be triggered by input strings that match a regex
(not just single symbols).</p></li>
</ol>
</div>
<p>To finish the proof, we make two observations:</p>
<p>First, you can convert any NFA to a GNFA by adding a special start
state that has an epsilon transition to the original start state and a
new accept state that has an epsilon transition from any old final
state.</p>
<p>Second, if you have a GNFA with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n &gt; 2</annotation></semantics></math>
states, there is an equivalent GNFA with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>
states, because you can remove any state (other than the initial and
final states) and replace incoming/outgoing transitions with transitions
described by a regex.</p>
<p>We did the following example to illustrate.</p>
<ol start="2" type="1">
<li>Let Σ={A,C,G,T}. Convert the following NFA to a GNFA, and then
remove states until there are only 2 (the start and accept states).</li>
</ol>
<center>
<img
src="https://people.hsc.edu/faculty-staff/blins/classes/fall23/coms461/ACGT.png" />
</center>
<!-- NOTE: YOU GET MORE THAN ONE ANSWER WHEN YOU DO THIS, AND IT DEPENDS ON HOW YOU DO IT (MAKE SURE TO INCLUDE ANY PATH THAT LOOPS BACK TO A STATE AS A LOOP! -->
<ol start="3" type="1">
<li>What regular expression is equivalent to the NFA above?</li>
</ol>
<p>We finished by talking about languages which are not regular. One
simple language that is not regular is the following:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>:</mo><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> has an equal number of </mtext><mspace width="0.333em"></mspace></mrow><mn>0</mn><mrow><mtext mathvariant="normal">s and </mtext><mspace width="0.333em"></mspace></mrow><mn>1</mn><mtext mathvariant="normal">s</mtext><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">A = \{w \in \{0,1\}^* : w \text{ has an equal number of } 0 \text{s and } 1 \text{s} \}.</annotation></semantics></math></p>
<!--

-->
<h3 id="week-5-notes">Week 5 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Feb 10</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=75">2.9</a></td>
<td style="text-align: left;">Non-regular languages &amp; the pumping
lemma</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Feb 12</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=75">2.9</a></td>
<td style="text-align: left;">More non-regular languages</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Feb 14</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">Review</td>
</tr>
</tbody>
</table>
<h4 id="mon-feb-10">Mon, Feb 10</h4>
<div class="Theorem">
<p><strong>Theorem (Pumping Lemma).</strong> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>
is a regular langauage, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
has a length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p \ge 1</annotation></semantics></math>
(called the <strong>pumping length</strong> of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>)
such that if a string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">w \in L</annotation></semantics></math>
is longer than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>,
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mi>x</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">w = xyz</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">x, y, z \in \Sigma^*</annotation></semantics></math>
are substrings such that</p>
<ol type="1">
<li>The middle part
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
is not the empty string (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>y</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|y| \ge 1</annotation></semantics></math>),</li>
<li>The first two parts have length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>x</mi><mi>y</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>≤</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">|xy| \le p</annotation></semantics></math>,
and</li>
<li>The middle part can be “pumped”, that is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msup><mi>y</mi><mi>n</mi></msup><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">xy^nz \in L</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \ge 0</annotation></semantics></math>.</li>
</ol>
</div>
<p>Here is a picture that helps to understand what is going on. It also
gives a clue about why this theorem is true.</p>
<center>
<img src="https://upload.wikimedia.org/wikipedia/commons/e/e8/Pumping_Lemma_for_regular_languages_diagram.png" width=500></img>
</center>
<p>The proof is really simple. If a finite state machine reads a long
enough string, eventually it has to loop back to the same state twice.
The input signals that caused the machine to take that loop make up the
substring
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
in the theorem.</p>
<p>The pumping lemma is a useful tool to prove that some languages are
not regular. You can use the pumping lemma to give a proof by
contradiction. Be careful, the pumping lemma cannot be used to prove
that a language <em>is</em> regular.</p>
<div class="Theorem">
<p><strong>Steps to prove a language is not regular</strong></p>
<ol type="1">
<li><p>Temporarily assume the language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
is regular and has pumping length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>.</p></li>
<li><p>Try to construct a string in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
so that:</p>
<ol type="a">
<li>The first part of the string is longer than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>.</li>
<li>No substring inside the first part can be pumped.</li>
</ol></li>
<li><p>If you can’t pump the string, that contradicts the pumping lemma,
so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
can’t be regular.</p></li>
</ol>
</div>
<p>We applied this technique to prove that the following languages are
not regular.</p>
<ol type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>:</mo><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> has an equal number of 0 and 1’s</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{w : w \text{ has an equal number of 0 and 1&#39;s}\}</annotation></semantics></math></li>
</ol>
<!--2. $L = \{ww : w \in \{0,1\}^* \}$ -->
<ol start="2" type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mn>0</mn><msup><mi>n</mi><mn>2</mn></msup></msup><mo>:</mo><mi>n</mi><mo>∈</mo><mi>ℕ</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{0^{n^2} : n \in \mathbb{N}\}</annotation></semantics></math>.</li>
</ol>
<p>Here is a nice <a
href="https://people.hsc.edu/faculty-staff/blins/classes/fall23/coms461/pumpinglemmaproof.png">meme
proof using the pumping lemma from Barak textbook</a>.</p>
<h4 id="wed-feb-12">Wed, Feb 12</h4>
<p>Today we looked at more examples of regular and non-regular
languages.</p>
<ol type="1">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>:</mo><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a palindrome</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{w \in \{0, 1\}^* : w \text{ is a palindrome} \}</annotation></semantics></math>.</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>:</mo><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> contains an equal number of </mtext><mspace width="0.333em"></mspace></mrow><mn>01</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><mn>10</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> substrings</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{w : w \text{ contains an equal number of } 01 \text{ and } 10 \text{ substrings}\}</annotation></semantics></math>.</p></li>
</ol>
<p>The converse of the pumping lemma is not true. So you can’t use the
pumping lemma to prove that a language is regular. In fact, here is a
language that is non-regular, but every string in the language is
pump-able!</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>i</mi></msup><msup><mi>b</mi><mi>j</mi></msup><msup><mi>c</mi><mi>k</mi></msup><mo>:</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi><mo>≥</mo><mn>0</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and if </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi><mo>=</mo><mn>1</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> then </mtext><mspace width="0.333em"></mspace></mrow><mi>j</mi><mo>=</mo><mi>k</mi><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">L = \{a^i b^j c^k : i, j, k \ge 0 \text{ and if } i = 1 \text{ then } j = k\}.</annotation></semantics></math></p>
<ol start="3" type="1">
<li><p>Explain why there is a pumping number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
(in fact
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p=1</annotation></semantics></math>
works) such that any string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">w \in L</annotation></semantics></math>
can be “pumped”.</p></li>
<li><p>Despite this, explain why
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
is not a regular language. Hint: if there was a DFA that recognizes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>,
what other DFAs could you construct?</p></li>
</ol>
<p>Many programming languages, including Python &amp; Javascript allow
backreferences to previous groups in a regular expression. A group is a
part of the regular expression inside parentheses. The special symbol
<code>\1</code> refers to anything matched by the first group in the
regular expression. Similarly <code>\2</code> refers back to anything
matched by the second group, and so on. For example: the regular
expression <code>"(\w\w*) \1"</code> would match any repeated word like
“word word” or “dog dog”. <em>I tried to demonstrate this in class, but
I got tripped up because Python requires the regular expression to be
entered as a</em> <a
href="https://docs.python.org/3/library/re.html#:~:text=raw%20string">raw
string</a>.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>regex <span class="op">=</span> <span class="vs">r&quot;(\w\w*) \1&quot;</span> <span class="co"># need the r before the quotes to indicate that this is a raw string</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(re.search(regex, <span class="st">&quot;Did I type the the same word twice?&quot;</span>))</span></code></pre></div>
<ol start="5" type="1">
<li>Explain why regular expressions with backreferences are not really
regular expressions (at least not according to our definition). Show
that they can match non-regular languages.</li>
</ol>
<h4 id="fri-feb-14">Fri, Feb 14</h4>
<p>Today we went over some of the problems from <a
href="HW/HW4.pdf">homework 4</a> and the <a
href="midterm1review.pdf">midterm 1 review problems</a>.</p>
<h3 id="week-6-notes">Week 6 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Feb 17</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><strong>Midterm 1</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Feb 19</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=99">3.1</a>
- <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=102">3.2</a></td>
<td style="text-align: left;">Context-free grammars</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Feb 21</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=108">3.3</a></td>
<td style="text-align: left;">Parsing and parse-trees</td>
</tr>
</tbody>
</table>
<h4 id="wed-feb-19">Wed, Feb 19</h4>
<p>Class canceled because of snow.</p>
<h4 id="fri-feb-21">Fri, Feb 21</h4>
<p>Today we introduced context-free grammars.</p>
<div class="Theorem">
<p><strong>Definition.</strong> A <strong>context-free grammar
(CFG)</strong> consists of</p>
<ol type="1">
<li>A set of <strong>variables</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math></li>
<li>A set of <strong>symbols</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
(disjoint from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>)</li>
<li>A set of <strong>rules</strong> of the form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \rightarrow B</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">A \in V</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>∈</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>Σ</mi><mo>∪</mo><mi>V</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">B \in (\Sigma \cup V)^*</annotation></semantics></math></li>
<li>A <strong>start state</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">S \in V</annotation></semantics></math>.</li>
</ol>
</div>
<p><!-- We started with some simple examples from Wikipedia (<https://en.wikipedia.org/wiki/Context-free_grammar#Examples>) to illustrate the definition.  --></p>
<ol type="1">
<li><p>We explained how the context free grammar</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>S         →  aSb</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>S         →  ε</span></code></pre></div>
<p>generates the (non-regular) language
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>n</mi></msup><msup><mi>b</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo>∈</mo><mi>ℕ</mi><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">L = \{a^n b^n : n \in \mathbb{N}\}.</annotation></semantics></math></p></li>
<li><p>We looked at the example of a CFG and used it to identify the
parts
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>V</mi><mo>,</mo><mi>Σ</mi><mo>,</mo><mi>R</mi><mo>,</mo><mi>S</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(V,\Sigma, R, S)</annotation></semantics></math>
in the formal definition.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>S         →  &lt;subject&gt; &lt;verb&gt; &lt;object&gt;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>&lt;subject&gt; →  &lt;article&gt; &lt;noun&gt;</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>&lt;article&gt; →  a | the</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>&lt;noun&gt;    →  boy | girl | dog</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>&lt;verb&gt;    →  runs | walks | talks</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>&lt;object&gt;  →  &lt;prep&gt; &lt;subject&gt;</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>&lt;prep&gt;    →  to |from</span></code></pre></div>
<p>Draw a parse tree that shows how to derive the sentence “The boy
talks to the girl.”</p></li>
<li><p>Find a CFG for the language of matched parentheses.</p>
<details>
<p>Seth suggested this CFG:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>     S         →  (S)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>     S         →  ()S</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>     S         →  ε</span></code></pre></div>
<p>This isn’t correct, but it is a good first guess. Explain why this
grammar cannot be used to construct the string <code>(())()</code>.</p>
</details></li>
<li><p>Find a context-free grammar for the language
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>:</mo><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> has an equal number of </mtext><mspace width="0.333em"></mspace></mrow><mn>0</mn><mrow><mtext mathvariant="normal">’s and </mtext><mspace width="0.333em"></mspace></mrow><mn>1</mn><mtext mathvariant="normal">’s</mtext><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">L = \{w \in \{0,1\}^* : w \text{ has an equal number of } 0\text{&#39;s and } 1 \text{&#39;s} \}.</annotation></semantics></math></p></li>
</ol>
<p>We didn’t get to this example, but it is good practice too.</p>
<ol start="5" type="1">
<li><p>Describe how to generate the string <code>(a + a) * a</code>
using the context free grammar below:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>&lt;expr&gt;    →  &lt;expr&gt; + &lt;term&gt; | &lt;term&gt;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>&lt;term&gt;    →  &lt;term&gt; <span class="ot">*</span> &lt;factor&gt; | &lt;factor&gt;</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>&lt;factor&gt;  →  (&lt;expr&gt;) | a</span></code></pre></div></li>
</ol>
<p>We finished by looking at this example that gives the idea of how a
programming language can be though of as a context-free language.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/File:C_grammar_stmt2_svg.svg"
class="uri">https://en.wikipedia.org/wiki/File:C_grammar_stmt2_svg.svg</a></li>
</ul>
<!--
#### Wednesday, September 27

Today, we briefly went over the first midterm exam. I talked about the [grading scale](gradingScale.html) and went over some of the problems . 

Today we spent more time discussing context free grammars. We talked about **left derivations** and **right derivations**

We looked at this example: 

$$E \rightarrow ~E+E~ | ~E*E~ | ~(E)~ | ~a~ $$

1. Use this CFG to derive the string $a+a*a$.  Try to use a left derivation.  Then use a right derivation.  

2. Show that that string actually has more than one left derivation.  

A grammar is **ambiguous** if there are strings with more than one left derivation.  If every left-derivation is unique, then the grammar is **unambiguous**. Note that some CFGs have unambiguous grammars, but so do not.  This alternate grammar generates the same language as our first example, but is unambiguous:

```
    <expr>    →  <expr> + <term> | <term>
    <term>    →  <term> * <factor> | <factor>
    <factor>  →  (<expr>) | a
```

We looked at this [ambiguous grammar](ambiguousGrammar.html).

3. Show that the sentence "the girl touches the boy with the flower" has two left derivations and those derivations correspond to two different meanings this sentence can have.  
<!--
Tips on constructing context free grammars:

1. To construct the union of two context-free languages: Use a new start variable with this production rule: $S \rightarrow S_1 | S_2$ where $S_1, S_2$ denote the start variables for the CFG's for $L_1$ and $L_2$ respectively.  From that point on, you just separately apply the rules for those two grammars.

2. It is 

#### Friday, September 29

Today we discussed the **pumping lemma for context-free languages**.  This is a little more complicated than the pumping lemma for regular languages. We drew some pictures of parse trees to give an intuitive explanation for why this new pumping lemma is true (see [page 126 in Maheshwari & Smid](https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=134)). In particular, we looked at how the string `a+a*a` gets generated by the grammar:

```
    E →  E + T | T
    T →  T * F | F
    F →  (E) | a
```

In the parse tree, there is a branch where the variable `T` gets repeated, and that lets us "pump".  

We used the pumping lemma to prove that the following languages are not context-free:

1. $L = \{a^n b^n c^n : n \in \N\}$.

1. $L = \{a^{n^2} : n \in \N\}$.

1. $L = \{w = w : w \in \{a, b\}^* \}$.

We also talked about how there are always an uncountable number of languages over a finite alphabet $\Sigma$ (since the set of languages is the power set of $\Sigma^*$), and a computer can only compute a countable set of languages, so it is not surprising that most languages are not context-free.  

--->
<h3 id="week-7-notes">Week 7 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Feb 24</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=108">3.3</a></td>
<td style="text-align: left;">Parsing and parse-trees</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Feb 26</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=132">3.8</a></td>
<td style="text-align: left;">The pumping lemma for CFGs</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Feb 28</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=120">3.5</a>
- <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=124">3.6</a></td>
<td style="text-align: left;">Pushdown automata</td>
</tr>
</tbody>
</table>
<h4 id="mon-feb-24">Mon, Feb 24</h4>
<p>Last time we used parse trees, but didn’t define them.</p>
<div class="Theorem">
<p><strong>Definition (Parse Tree).</strong> Given a context free
grammar
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>V</mi><mo>,</mo><mi>Σ</mi><mo>,</mo><mi>S</mi><mo>,</mo><mi>R</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(V, \Sigma, S, R)</annotation></semantics></math>
and a string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">w \in \Sigma^*</annotation></semantics></math>
that can be generated by the grammar, a <strong>parse tree</strong> for
the string is a labeled <a
href="https://en.wikipedia.org/wiki/Tree_(graph_theory)#Ordered_tree">ordered
tree</a> with nodes labeled by elements in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>∪</mo><mi>Σ</mi></mrow><annotation encoding="application/x-tex">V \cup \Sigma</annotation></semantics></math>
such that the arrows leaving a node labeled by an element in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
correspond to one of the rules in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
and the nodes labeled by elements in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
are terminal (no arrows leave them).</p>
</div>
<p>Today we looked at some more examples of Context Free Grammars. <a
href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>
is a family of programming languages that have a particularly simple
syntax. Lisps are built around S-expressions, which are defined by the
following CFG rules:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>S → (L) | A</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>L → S | S L</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>A → &lt;number&gt; | &lt;string&gt; | &lt;symbol&gt;</span></code></pre></div>
<p>For the variables above, <code>S</code> represents any S-expression,
<code>L</code> represents a list, and <code>A</code> represents an atom,
which can be a number, a string, or a symbolic expression like a
variable name or operator (among other things).</p>
<ol type="1">
<li><p>Draw a parse tree for the S-expression
<code>(* (+ 5 6) (- 4 2))</code>. Each node in the parse tree should be
labeled with a variable (or symbol if it is a terminal node).</p></li>
<li><p>Is it possible to draw a different parse tree for this
expression? Why or why not?</p></li>
</ol>
<p>The S-expression grammar is <strong>unambigious</strong>, every
expression has only one possible parse tree. Unfortunately, many CFGs
are <strong>ambiguous</strong>, i.e., they allow strings with more than
one parse tree. Here is a simple example.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>E → E + E </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>E → E <span class="ot">*</span> E </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>E → (E) </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>E → a</span></code></pre></div>
<ol start="3" type="1">
<li>Use this CFG to derive the string <code>a+a*a</code> two different
ways.</li>
</ol>
<p>In some (but not all cases) it is possible to find two CFGs that
generate the same set of strings, but one is ambiguous and the other
isn’t. For example, if we change the grammar above to distinguish
between expressions that are terms (<code>T</code>), or factors
(<code>F</code>) or sums of terms (<code>E</code>), then we can make an
equivalent CFG that is unambiguous:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>E  →  E + T | T</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>T  →  T <span class="ot">*</span> F | F</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>F  →  (E) | a</span></code></pre></div>
<!--
Sentences in ambiguous grammars are hard to parse, since they might have different meanings depending on how they are derived. For example, the sentence "the girl touches the boy with the flower" is ambiguous in English.  
-->
<p>We say that a language is <strong>context-free</strong> if it can be
generated by a CFG. We use the shorthand CFL to denote a context-free
language.</p>
<div class="Theorem">
<p><strong>Theorem (Regular Languages are Context-Free).</strong> Every
regular language is context-free.</p>
</div>
<p>We’ll prove this later by showing that context-free grammars
correspond to a special kind of automata with a (potentially infinte)
stack called a pushdown automata. But today, we talked about how you can
prove this theorem using the three operations (union, concatenation, and
Kleene star) for regular expressions.</p>
<ol start="4" type="1">
<li><p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are both context-free languages, explain why the union
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math>
is context free.</p></li>
<li><p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are both context-free languages, explain why the concatenation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∘</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A \circ A</annotation></semantics></math>
is context free.</p></li>
<li><p>Explain why the Kleene star of a CFL is context-free.</p></li>
</ol>
<!--
We looked at this [ambiguous grammar](https://people.hsc.edu/faculty-staff/blins/classes/fall23/coms461/ambiguousGrammar.html).

3. Show that the sentence "the girl touches the boy with the flower" has two left derivations and those derivations correspond to two different meanings this sentence can have.  



Tips on constructing context free grammars:

1. To construct the union of two context-free languages: Use a new start variable with this production rule: $S \rightarrow S_1 | S_2$ where $S_1, S_2$ denote the start variables for the CFG's for $L_1$ and $L_2$ respectively.  From that point on, you just separately apply the rules for those two grammars.
-->
<h4 id="wed-feb-26">Wed, Feb 26</h4>
<div class="Theorem">
<p><strong>Theorem (Pumping Lemma for CFLs)</strong>. If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>
is a context-free language, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
has a length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p \ge 1</annotation></semantics></math>
(called the <strong>pumping length</strong> of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>)
such that if a string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">w \in L</annotation></semantics></math>
is longer than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">p,</annotation></semantics></math>
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mi>u</mi><mi>v</mi><mi>x</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">w = uvxyz</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>,</mo><mi>v</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">u, v, x, y, z \in \Sigma^*</annotation></semantics></math>
are substrings such that</p>
<ol type="1">
<li>At least one of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
is not empty (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>v</mi><mi>y</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|vy| \ge 1</annotation></semantics></math>),</li>
<li>The middle part has length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>v</mi><mi>x</mi><mi>y</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>≤</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">|vxy| \le p</annotation></semantics></math>,
and</li>
<li>Both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
can be “pumped”, that is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><msup><mi>v</mi><mi>n</mi></msup><mi>x</mi><msup><mi>y</mi><mi>n</mi></msup><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">uv^nxy^nz \in L</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \ge 0</annotation></semantics></math>.</li>
</ol>
</div>
<p>This is a little more complicated than the pumping lemma for regular
languages. We drew some pictures of parse trees to give an intuitive
explanation for why this new pumping lemma is true (see <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=134">page
126 in Maheshwari &amp; Smid</a>).</p>
<p>We started by looking at two examples:</p>
<ol type="1">
<li><p>Show that the language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>n</mi></msup><mi>b</mi><msup><mi>a</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo>∈</mo><mi>ℕ</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{a^n b a^n : n \in \mathbb{N}\}</annotation></semantics></math>
is context-free but not regular.</p></li>
<li><p>What is the pumping length for the language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
above?</p></li>
<li><p>Show that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>=</mo><mi>w</mi><mo>:</mo><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{w = w : w \in \{a, b\}^* \}</annotation></semantics></math>
is not context-free.</p></li>
</ol>
<!--
In particular, we looked at how the string `a+a*a` gets generated by the grammar:

```
    E →  E + T | T
    T →  T * F | F
    F →  (E) | a
```

In the parse tree, there is a branch where the variable `T` gets repeated, and that lets us "pump".  
-->
<ol start="4" type="1">
<li>Show that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><msup><mi>n</mi><mn>2</mn></msup></msup><mo>:</mo><mi>n</mi><mo>∈</mo><mi>ℕ</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{a^{n^2} : n \in \mathbb{N}\}</annotation></semantics></math>
is not context-free.</li>
</ol>
<p>We didn’t have time for this last problem, so I left it as an
exercise to consider:</p>
<ol start="5" type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>n</mi></msup><msup><mi>b</mi><mi>n</mi></msup><msup><mi>c</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo>∈</mo><mi>ℕ</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A = \{a^n b^n c^n : n \in \mathbb{N}\}</annotation></semantics></math>
is not context-free. What about the language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>⊂</mo><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">B \subset \{a,b,c\}^*</annotation></semantics></math>
that consists of all strings with an equal number of a’s, b’s, and c’s?
Is that context-free?</li>
</ol>
<!--
We also talked about how there are always an uncountable number of languages over a finite alphabet $\Sigma$ (since the set of languages is the power set of $\Sigma^*$), and a computer can only compute a countable set of languages, so it is not surprising that most languages are not context-free.  -->
<h4 id="fri-feb-28">Fri, Feb 28</h4>
<p>Today we talked about <strong>pushdown automata (PDA)</strong> which
are basically just NFAs with a stack. Note that the <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=120">book
calls these nondeterministic pushdown automata</a>. There are also
deterministic pushdown automata, but those turn out to be more
complicated, and only the nondeterministic pushdown automata are
actually equivalent to CFGs. So, we will always assume that our PDAs are
nondeterministic, unless specifically mentioned otherwise. We started
with this example:</p>
<center>
<img
src="https://people.hsc.edu/faculty-staff/blins/classes/fall23/coms461/NPDA1.png" />
</center>
<p>This PDA accepts the language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>n</mi></msup><msup><mi>b</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo>∈</mo><mi>ℕ</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{a^n b^n : n \in \mathbb{N}\}</annotation></semantics></math>.
Notice that each arrow has three parts, for example the first loop is
labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>ϵ</mi><mi>/</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">a, \epsilon/a</annotation></semantics></math>
which means you can take this loop if you read an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
from the input string, and pop
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math>
(i.e., nothing) from the stack, and then push
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
onto the stack. We will always use this notation (read, pop/push) for
each arc.</p>
<p>PDAs work just like NFAs, except they have this extra rule: <em>You
only accept a string if you finish in an accepting state and the stack
is empty.</em></p>
<p>Some things to note:</p>
<ol type="1">
<li><p>Since the machine is nondeterministic, you can have more than one
state (and more than one stack) branching off whenever you have a choice
about which arrow to take.</p></li>
<li><p>If you are in a state and there is no valid arrow to take, then
that state dies.</p></li>
</ol>
<p>Here is the formal definition.</p>
<div class="Theorem">
<p><strong>Definition.</strong> A <strong>nondeterministic pushdown
automata (PDA)</strong> consists of</p>
<ol type="1">
<li>A finite set of <strong>states</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>.</li>
<li>A finite <strong>input alphabet</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>.</li>
<li>A finite <strong>stack alphabet</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>.</li>
<li>A <strong>transition function</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Σ</mi><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mi>ϵ</mi><mo stretchy="false" form="postfix">}</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Γ</mi><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mi>ϵ</mi><mo stretchy="false" form="postfix">}</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><msup><mn>2</mn><mrow><mi>Q</mi><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Γ</mi><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mi>ϵ</mi><mo stretchy="false" form="postfix">}</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup></mrow><annotation encoding="application/x-tex">\delta: Q \times (\Sigma \cup \{\epsilon\}) \times (\Gamma \cup \{ \epsilon \}) \rightarrow 2^{Q \times (\Gamma \cup \{\epsilon\})}</annotation></semantics></math>.</li>
<li>A <strong>start state</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0 \in Q</annotation></semantics></math>.</li>
<li>A set of <strong>accepting states</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">F \subseteq Q</annotation></semantics></math>.</li>
</ol>
<p>Note: Some alternative definitions allow PDAs to push more than one
symbol from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>
onto the stack in one step.</p>
</div>
<p>We looked at these questions:</p>
<ol type="1">
<li><p>For the PDA below, describe the language that it accepts.<br />
</p>
<center>
<p><img
src="https://people.hsc.edu/faculty-staff/blins/classes/fall23/coms461/NPDA2.png" /></p>
</center></li>
<li><p>Describe an PDA that accepts the language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>n</mi></msup><msup><mi>b</mi><mi>m</mi></msup><mo>:</mo><mi>n</mi><mo>≥</mo><mi>m</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{ a^n b^m : n \ge m \}</annotation></semantics></math>.</p></li>
<li><p>Describe an PDA with just one state that accepts the language of
balanced parentheses.</p></li>
<li><p>How many distinct PDAs with 5 states, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo>=</mo><mi>Γ</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\Sigma = \Gamma = \{0,1\}</annotation></semantics></math>
are possible (assuming you only push at most one variable onto the stack
at each step), according to the definition?</p></li>
</ol>
<!--
#### Wednesday, October 4

Today we talked about the equivalence between CFGs and NPDAs.  We sketched the proof of one direction: that if you have a CFG, then there is an NPDA that accepted the same language.  

The idea of the proof is to create an NPDA with three states.  In state $q_0$ you immediately transition to $q_1$ reading nothing and push `S$` on the stack (where `$` is a special symbol to mark the bottom of the stack).  Then in state $q_1$ you have two different types of transitions that loop back to $q_1$:

1. Transitions where you read nothing and pop a variable off the stack, then push the output of one of the grammar rules for that variable back onto the stack. (I called these red transitions.) You have one red transition for each of the rules in the grammar.

2. Transitions where you read a symbol from the input and pop that symbol off the stack.  (I called these blue transitions.) You have one blue transition for each of the terminals in the grammar.

Finally, you have a final transition to the accepting state $q_2$ which involves reading nothing and popping the `$` off the stack.  If you have finished reading the input when you do this, you will accept the string.  

We illustrated how this idea works using the grammar and the input string `aabbbb`. 

```
    S →  AB
    A →  aAb | ε
    B →  bB | b
```

We finished by describing how Deterministic Pushdown Automata (DPDAs) are different from Nondeterministic Pushdown Automata (NPDAs) and the hierarchy of different languages that we have seen so far.  We looked at this example DPDA:

<center>
![](https://people.hsc.edu/faculty-staff/blins/classes/fall23/coms461/DPDA.png)
</center>

-->
<h3 id="week-8-notes">Week 8 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Mar 3</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=128">3.7</a></td>
<td style="text-align: left;">Pushdown automata &amp; context-free
grammars</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Mar 5</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=112">3.4</a></td>
<td style="text-align: left;">Chomsky normal form</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Mar 7</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=145">4.1</a>
- <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=149">4.2</a></td>
<td style="text-align: left;">Definition of Turing machines</td>
</tr>
</tbody>
</table>
<h4 id="mon-mar-3">Mon, Mar 3</h4>
<p>Today we talked about the equivalence between CFGs and PDAs.</p>
<div class="Theorem">
<p><strong>Theorem (Equivalence of CFGs and PDAs).</strong> A language
is context-free if and only if there is a pushdown automata that
recognizes it.</p>
</div>
<p>We sketched the proof of one direction: that if you have a CFG, then
there is an PDA that accepts the same language. The other direction is
harder to prove, so we skipped it, but you can find the details in more
advanced theory of computing textbooks.</p>
<p>The idea of the proof for the forward direction is to create an PDA
with three states. In state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>0</mn></msub><annotation encoding="application/x-tex">q_0</annotation></semantics></math>
you immediately transition to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>1</mn></msub><annotation encoding="application/x-tex">q_1</annotation></semantics></math>
reading nothing and push <code>S$</code> on the stack (where
<code>$</code> is a special symbol to mark the bottom of the stack and
<code>S</code> is the symbol for the start variable). Then in state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>1</mn></msub><annotation encoding="application/x-tex">q_1</annotation></semantics></math>
you have two different types of transitions that loop back to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>1</mn></msub><annotation encoding="application/x-tex">q_1</annotation></semantics></math>:</p>
<ul>
<li>(<span style="color:red">Red loops - one for each rule </span>)
<ol type="i">
<li>Read nothing</li>
<li>Pop a variable off the stack</li>
<li>Push the output of one of the grammar rules for that variable back
onto the stack.</li>
</ol></li>
<li>(<span style="color:blue">Blue loops - one for each input alphabet
symbol</span>)
<ol type="i">
<li>Read a symbol from the input</li>
<li>Pop that symbol off the stack.<br />
</li>
<li>Push nothing</li>
</ol></li>
</ul>
<p>Finally, you have a final transition to the accepting state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>2</mn></msub><annotation encoding="application/x-tex">q_2</annotation></semantics></math>
which involves reading nothing and popping the <code>$</code> off the
stack. If you have finished reading the input when you do this, you will
accept the string.</p>
<p>We illustrated how this idea works using the grammar and the input
string <code>aabbbb</code>.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    S →  AB</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    A →  aAb | ε</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    B →  bB | b</span></code></pre></div>
<p>After this example, we talked briefly about normal forms for
context-free grammars. One important normal form is the Chomsky normal
form, which we will talk about next time.</p>
<p>For a context-free grammar
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>,
we write
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>G</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math>
to denote the language generated by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>.</p>
<ol type="1">
<li><p>A variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
in a context-free grammar
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>
is <strong>useless</strong> if there are no strings in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>G</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">L(G)</annotation></semantics></math>
that have a parse tree with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
as one of the nodes. Prove that if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>
has any useless variables, then there is another context-free grammar
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
that generates the same language, but does not have any useless
variables.</p>
<details>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
be the CFG obtained by removing all useless variables from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>
and all rules that reference those useless variables. We have to show
that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>
both generate the same language. If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>G</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w \in L(G)</annotation></semantics></math>,
then there is a parse tree for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>
that doesn’t contain any useless variables. Therefore the same parse
tree is a parse tree for generating
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>
using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>,
so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>H</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w \in L(H)</annotation></semantics></math>.
If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>H</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w \in L(H)</annotation></semantics></math>,
then all of the variables and rules for the parse tree to generate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>
are also variables and rules of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>.
Therefore
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>G</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">w \in L(G)</annotation></semantics></math>
which proves that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>H</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>G</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">L(H) = L(G)</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>▫</mi><annotation encoding="application/x-tex">\square</annotation></semantics></math></p>
</details></li>
</ol>
<h4 id="wed-mar-5">Wed, Mar 5</h4>
<div class="Theorem">
<p><strong>Definition (Chomsky normal form).</strong> A context free
grammar
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>V</mi><mo>,</mo><mi>Σ</mi><mo>,</mo><mi>R</mi><mo>,</mo><mi>S</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">G = (V, \Sigma, R, S)</annotation></semantics></math>
is in <strong>Chomsky normal form</strong> if all rules are in one of
the following forms:</p>
<ol type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">S \rightarrow \epsilon</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">A \rightarrow BC</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \rightarrow a</annotation></semantics></math></li>
</ol>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>C</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">A, B, C \in V</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>Σ</mi></mrow><annotation encoding="application/x-tex">a \in \Sigma</annotation></semantics></math>,
and neither
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
nor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
is the start variable.</p>
</div>
<p>One nice feature of Chomsky normal form is that it makes it easier to
check whether a string can be generated by a grammar.</p>
<div class="Theorem">
<p><strong>Definition (Equivalent grammars).</strong> Two context-free
grammars are equivalent if they generate the same language.</p>
</div>
<p>It turns out that there is no general algorithm to check whether or
not two CFGs are equivalent. But all CFGs can be converted to Chomsky
normal form.</p>
<div class="Theorem">
<p><strong>Theorem (Chomsky).</strong> Every CFG is equivalent to a CFG
in Chomsky normal form.</p>
</div>
<p>The proof is the following algorithm to convert any CFG into Chomsky
normal form.</p>
<ul>
<li><p><strong>Step 1 (Preliminaries).</strong></p>
<ol type="i">
<li>If any rule has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
on the right-hand side, then add a new start variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>S</mi><mn>0</mn></msub><annotation encoding="application/x-tex">S_0</annotation></semantics></math>
and rule
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">S_0 \rightarrow S</annotation></semantics></math>
so that the start variable never appears on the right side of a rule. If
the grammar can generate the empty string, then add the rule
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">S_0 \rightarrow \epsilon</annotation></semantics></math>.</li>
<li>Remove any
<strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math>-rules</strong>.
If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">A \rightarrow \epsilon</annotation></semantics></math>
is a rule (where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is not the start variable), then for any rule with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
on the right-hand side, add an alternative version without the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.</li>
<li>Remove any <strong>unit rules</strong>. Replace any rule
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \rightarrow B</annotation></semantics></math>
with rules that directly transition from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
to any string that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
can transition to.</li>
</ol></li>
<li><p><strong>Step 2 (Add terminal variables).</strong> For each
terminal symbol
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>Σ</mi></mrow><annotation encoding="application/x-tex">a \in \Sigma</annotation></semantics></math>,
create a variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mi>a</mi></msub><annotation encoding="application/x-tex">T_a</annotation></semantics></math>
and add the rule
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">T_a \rightarrow a</annotation></semantics></math>.
If a rule has more than one symbol in its output, then replace any
terminal symbols with their corresponding terminal variables.</p></li>
<li><p><strong>Step 3 (Break up long rules).</strong> For any rule of
the form
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><msub><mi>X</mi><mn>1</mn></msub><msub><mi>X</mi><mn>2</mn></msub><mi>⋯</mi><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A \rightarrow X_1 X_2 \cdots X_n</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n &gt; 2</annotation></semantics></math>,
create new variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>U</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">U_1, \ldots, U_{n-2}</annotation></semantics></math>
and so that you can replace the long rule with the following shorter
rules:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo>→</mo><msub><mi>X</mi><mn>1</mn></msub><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_1 \rightarrow X_1 U_2</annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>2</mn></msub><mo>→</mo><msub><mi>X</mi><mn>2</mn></msub><msub><mi>U</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">U_2 \rightarrow X_2 U_3</annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⋯</mi><annotation encoding="application/x-tex">\cdots</annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>→</mo><msub><mi>X</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">U_{n-2} \rightarrow X_{n-1} X_n</annotation></semantics></math></p></li>
</ul>
<p>At the end of this process your grammar will be in Chomsky normal
form.</p>
<ol type="1">
<li><p>Convert the following CFG to Chomsky normal form.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>S → ABa</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>A → aab</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>B → Ac</span></code></pre></div></li>
<li><p>Convert the following CFG to Chomsky normal form.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>S → aSa | A</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>A → abA | b</span></code></pre></div></li>
<li><p>Explain why the following algorithm won’t work to check if any
two CFGs are equivalent:</p>
<ul>
<li>Step 1 - Convert both CFGs to Chomsky normal form.</li>
<li>Step 2 - Check to see if the two Chomsky normal forms are the
same.</li>
</ul></li>
</ol>
<p>We didn’t have time for it today, but here is one more practice
example:</p>
<ol start="4" type="1">
<li><p>Convert the following CFG to Chomsky normal form.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>S → ASA | A | ε</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>A → aa | ε</span></code></pre></div></li>
</ol>
<h4 id="fri-mar-7">Fri, Mar 7</h4>
<p>Today we introduced <strong>Turing machines</strong> (TMs) which are
the most general model of computation that we will discuss. Turing
machines are deterministic finite state machines, with an infinite tape
that the machine can move along, and both read and write from. Like DFAs
and PDAs, Turing machines can accept or reject an input string, but
Turing machines also have a third possibility: they might loop forever
and neither accept nor reject.</p>
<p>Here are some differences between finite automata and Turing
machines:</p>
<ul>
<li><p>The input string is initially written on the tape and the Turing
machine is initially pointed at the first symbol of the input
string.</p></li>
<li><p>Aside from the input string, the tape is initially filled with
special blank symbols (which we’ll denote □).</p></li>
<li><p>The Turing machine can read and (optionally) replace one symbol
on the tape at a time before moving left or right.</p></li>
<li><p>The TM can have both accept and reject states. When the Turing
machine enters one of these states, it immediately halts and the program
is complete.</p></li>
<li><p>A TM might loop forever without ever accepting or rejecting a
string.</p></li>
</ul>
<p>We looked at these examples of TMs:</p>
<ol type="1">
<li><p>Describe an algorithm that a Turing machine could implement to
check if a string in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mo>=</mo><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">\{a,b,=\}^*</annotation></semantics></math>
is in the language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>=</mo><mi>w</mi><mo>:</mo><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{w=w : w \in \{a,b\}^* \}</annotation></semantics></math>.
Use the tape alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mo>=</mo><mo>,</mo><mi>x</mi><mo>,</mo><mi>□</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{a,b,=,x, □\}</annotation></semantics></math>,
where you can use an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
to mark symbols that have been dealt with. Hint: How could you check
that the first character of the string matches the first character after
the equals sign?</p></li>
<li><p>Draw a state diagram for the Turing machine above. Use the
notation
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">read</mtext><mo>→</mo><mtext mathvariant="normal">write</mtext><mo>,</mo><mtext mathvariant="normal">move</mtext></mrow><annotation encoding="application/x-tex">\text{read} \rightarrow \text{write}, \text{move}</annotation></semantics></math>
to label transitions. The move can be either
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>,
and you can use regular expressions for the character to read. The
character to write is optional, you can move without writing
anything.<br />
<!-- NOTE FOR NEXT TIME: THIS STATE DIAGRAM IS WAY TOO COMPLICATED TO DO IN CLASS.  DO A SIMPLER EXAMPLE. THERE ARE SIMPLE 3 STATE EXAMPLES YOU COULD USE INSTEAD.--></p></li>
<li><p>Describe an algorithm that a TM could use to accept the language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><msup><mn>2</mn><mi>n</mi></msup></msup><mo>:</mo><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">\{a^{2^n} : n \ge 0\}.</annotation></semantics></math>
Hint: Try moving from left to right, crossing out every other
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
as you go. How will you know if there were an even number of a’s? Could
you repeat the process? When should you stop?</p></li>
</ol>
<p>We didn’t get to it in class, but here is a state diagram for a TM
that can accept the language
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><msup><mn>2</mn><mi>n</mi></msup></msup><mo>:</mo><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">L = \{a^{2^n}: n \ge 0\}.</annotation></semantics></math></p>
<center>
<img src="TM.png" width = 600></img>
</center>
<!-- Note to self: These are examples 3.7 & 3.9 in Sipser.-->
<h3 id="week-9-notes">Week 9 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Mar 17</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=149">4.2</a></td>
<td style="text-align: left;">Turing computable functions</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Mar 19</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=156">4.3</a></td>
<td style="text-align: left;">Multi-tape Turing machines</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Mar 21</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=159">4.4</a></td>
<td style="text-align: left;">Church-Turing thesis</td>
</tr>
</tbody>
</table>
<h4 id="mon-mar-17">Mon, Mar 17</h4>
<p>Here is the formal definition of a Turing machine.</p>
<div class="Theorem">
<p><strong>Definition.</strong> A <strong>Turing machine</strong>
consists of</p>
<ol type="1">
<li>A finite set of <strong>states</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>.</li>
<li>A finite <strong>input alphabet</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
that doesn’t include the blank symbol □.</li>
<li>A finite <strong>tape alphabet</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo>⊂</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Sigma \subset \Gamma</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>□</mi><mo>∈</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">□ \in \Gamma</annotation></semantics></math>.</li>
<li>A <strong>transition function</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi>Γ</mi><mo>→</mo><mi>Q</mi><mo>×</mo><mi>Γ</mi><mo>×</mo><mo stretchy="false" form="prefix">{</mo><mi>L</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}</annotation></semantics></math>.</li>
<li>A <strong>start state</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0 \in Q</annotation></semantics></math>.</li>
<li>An <strong>accept state</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mtext mathvariant="normal">accept</mtext></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_{\text{accept}} \in Q</annotation></semantics></math>.</li>
<li>A <strong>reject state</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mtext mathvariant="normal">reject</mtext></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_{\text{reject}} \in Q</annotation></semantics></math>.</li>
</ol>
</div>
<p>Because Turing machines can loop forever, there is a difference
between recognizing/accepting a language and deciding a language.</p>
<div class="Theorem">
<p><strong>Definition.</strong> A Turing machine
<strong>accepts</strong> (or <strong>recognizes</strong>) a language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>
if the set of strings that it accepts is exactly
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>.</p>
</div>
<p>A Turing machine that only recognizes a language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
might loop forever when you give it a string that is not in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>.</p>
<div class="Theorem">
<p><strong>Definition.</strong> A Turing machine
<strong>decides</strong> a language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>
if it not only recognizes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>,
but also rejects every string that is not in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>.</p>
</div>
<p>Both of the example Turing Machines above actually decide their
languages, since they will successfully reject any input that doesn’t
match a valid string (they won’t get stuck looping forever without
halting). We’ll see examples later of Turing machines that accept but
don’t decide a language.</p>
<p>Another thing that Turing Machines can do is compute functions by
leaving the output on the tape when it halts.</p>
<ol type="1">
<li>Construct a Turing machine that reads an input string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mi>a</mi><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">w \in \{a\}^*</annotation></semantics></math>
and leaves
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">ww</annotation></semantics></math>
on the tape when it halts. <!--*--></li>
</ol>
<p>This wasn’t to hard to describe the algorithm, but it got a little
complicated when we made the state diagram. Once we did that, we defined
Turing computable functions.</p>
<div class="Theorem">
<p><strong>Definition.</strong> A function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">f: \Sigma^* \rightarrow \Sigma^*</annotation></semantics></math>
is <strong>Turing computable</strong> if there is a Turing machine that
halts with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>w</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(w)</annotation></semantics></math>
on the tape whenever it is given a tape with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">w \in \Sigma^*</annotation></semantics></math>
as input.</p>
</div>
<ol start="2" type="1">
<li>Explain why the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>w</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>w</mi><mi>w</mi><mi>w</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">f(w) = wwww</annotation></semantics></math>
is Turing computable.</li>
</ol>
<div class="Theorem">
<p><strong>Theorem (Compostions are computable).</strong> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>,</mo><mi>g</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">f, g : \Sigma^* \rightarrow \Sigma^*</annotation></semantics></math>
are both Turing computable functions, then so is the composition
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f \circ g</annotation></semantics></math>.</p>
</div>
<ol start="3" type="1">
<li>Explain why the function
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>w</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mn>1</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if length of </mtext><mspace width="0.333em"></mspace></mrow><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is even.</mtext></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>0</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> otherwise.</mtext></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(w) = \begin{cases} 1 &amp; \text{ if length of } w \text{ is even.} \\ 0 &amp; \text{ otherwise.} \end{cases}</annotation></semantics></math>
is Turing computable. Hint: Every regular language is Turing
decidable.</li>
</ol>
<p>We finished by describing how this function (which comes up in the <a
href="https://en.wikipedia.org/wiki/Collatz_conjecture">Collatz-Conjecture</a>)
is Turing computable:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mi>n</mi><mi>/</mi><mn>2</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mi>n</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is even,</mtext></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>3</mn><mi>n</mi><mo>+</mo><mn>1</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mi>n</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is odd.</mtext></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(n) = \begin{cases}
n/2 &amp; \text{ if } n \text{ is even,}  \\
3n+1 &amp; \text{ if } n \text{ is odd.} \end{cases}</annotation></semantics></math></p>
<h4 id="wed-mar-19">Wed, Mar 19</h4>
<p>Today we looked at <strong>multi-tape Turing machines</strong>.</p>
<div class="Theorem">
<p><strong>Theorem.</strong> Any k-tape Turing machine has an equivalent
single-tape Turing machine.</p>
</div>
<p><em>Proof idea.</em> For every tape symbol of the k-tape TM, we need
a “dotted” symbol and we also need a special separator symbol (#). Then
we can put the contents of the k tapes onto a single tape if we add
separators and dotted symbols to mark the which symbols are currently
pointed to by the TM.</p>
<center>
<table class="bordered">
<tr>
<td>
#
</td>
<td>
a
</td>
<td>
ȧ
</td>
<td>
□
</td>
<td>
a
</td>
<td>
#
</td>
<td>
ḃ
</td>
<td>
b
</td>
<td>
b
</td>
<td>
a
</td>
<td>
#
</td>
<td>
a
</td>
<td>
a
</td>
<td>
a
</td>
<td>
ȧ
</td>
<td>
#
</td>
</tr>
</table>
</center>
<p>For each step of the k-tape TM, the 1-tape TM follows these
rules:</p>
<ul>
<li><p>Starting from the left, it reads the dotted symbols for each of
the k-substrings. Then it returns to the leftmost position.</p></li>
<li><p>Then it makes a 2nd pass, updating the contents at each dotted
symbol, and then moving the dot to the left or right.</p></li>
<li><p>If it reaches the end of a substring but needs to add a
character, it first prints a special-blank then shifts every other
character to the right by one, before returning to the special-blank and
proceeding.</p></li>
</ul>
<p>Another variation on a standard TM is a <strong>nondeterministic
Turing machine (NTM)</strong>. At each step, these can split into more
than one possible next state. The transition function has form:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi>Γ</mi><mo>→</mo><msup><mn>2</mn><mrow><mi>Q</mi><mo>×</mo><mi>Γ</mi><mo>×</mo><mo stretchy="false" form="prefix">{</mo><mi>L</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">}</mo></mrow></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">\delta: Q \times \Gamma \rightarrow 2^{Q \times \Gamma \times \{L, R \}}.</annotation></semantics></math>
The nondeterministic TM accepts a language as soon as any of its
parallel versions reaches an accept state.</p>
<div class="Theorem">
<p><strong>Theorem.</strong> Any language that can be accepted by a
nondeterministic Turing machine can also be accepted by a regular Turing
machine.</p>
</div>
<p>We talked about how you can use a 3-tape TM to used a breadth first
search through the branching possibilities of a NTM to see if any
accept.<br />
<!--
*Proof idea.* We'll construct a regular 3-tape TM that simulates our NTM.  The key is to do a breadth first search through the tree of possible branches the NTM can take.  If you think of the branches that the NTM can take as a tree, then you can label every node of the tree with an integer.  Then simulate the NTM deterministically 
--></p>
<p>We also talked about other things that a TM can do:</p>
<ol type="1">
<li><p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f: \Sigma^* \rightarrow \{0,1\}</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>,</mo><mi>h</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">g, h: \Sigma^* \rightarrow \Sigma^*</annotation></semantics></math>
are Turing computable, then so is the function</p>
<center>
<p><code>IF f(x) THEN g(x) ELSE h(x).</code></p>
</center></li>
<li><p>What about a while-loop?</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span>(f(x)):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> g(x)</span></code></pre></div></li>
</ol>
<p>We didn’t have time for this last example:</p>
<ol start="3" type="1">
<li><p>Can a Turing machine have a for-loop, where it repeats some
function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
times? Something like this <code>Python</code> example where function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>
is applied
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
times?</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n): </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> f(x)</span></code></pre></div></li>
</ol>
<h4 id="fri-mar-21">Fri, Mar 21</h4>
<p>We started with this example:</p>
<ol type="1">
<li>Suppose that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">f: \Sigma^* \rightarrow \Sigma^*</annotation></semantics></math>
is a Turing computable function. Describe a 2-tape TM that inputs a
string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">x \in \Sigma^*</annotation></semantics></math>
on one tape and a number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
(encoded with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
1’s) on the second tape, that computes
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mi>k</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><munder><munder><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>⋯</mi><mi>f</mi><mo stretchy="false" form="prefix">(</mo></mrow><mo accent="true">⏟</mo></munder><mrow><mi>k</mi><mtext mathvariant="normal">-times</mtext></mrow></munder><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">f^{k}(x) := \underbrace{f(f(\cdots f(}_{k\text{-times}}x)))).</annotation></semantics></math></li>
</ol>
<p>In mathematics, there are many algorithms, which are step-by-step
procedures that can be carried out to solve problems. Prior to the work
of Turing and other computer scientists, no one ever tried to define
exactly what an algorithm is. It turns out to be hard to give a precise
definition of an algorithm. Computer scientists have settled on the
following:</p>
<div class="Theorem">
<p><strong>Definition (Church-Turing thesis).</strong> An
<strong>algorithm</strong> is a computational task that can be carried
out by a Turing machine.</p>
</div>
<p>The idea is that Turing machines can do all of the things (like
looping, and conditionals, storing variables) that we think of
algorithms as doing, so we use TMs to give a precise definition for
algorithms.</p>
<p>There are many other models of computing that can be proven to be
<strong>Turing complete</strong>, that is, they can compute the same
functions as Turing machines. But it is believed that there is no <a
href="https://en.wikipedia.org/wiki/Effective_method">effective
method</a> of computation that can solve problems that Turing machines
cannot solve.</p>
<p>We finished by discussing Hilbert’s 10th problem: Is there an
algorithm to determine whether or not a multivariable polynomial with
integer coefficients has an integer root? We looked at some example
polynomials like</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>2</mn><mi>x</mi><mi>y</mi><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">p(x,y) = 3x^2 - 2xy + y^2 - 2</annotation></semantics></math>
and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">q(x,y) = x^2 + y^2 + 1.</annotation></semantics></math>
The pair
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math>
is a root for the first polynomial, since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p(1,1) = 0</annotation></semantics></math>,
but the second polynomial has no integer roots.</p>
<ol start="2" type="1">
<li>Describe an algorithm that we could implement using a TM or computer
program to try to find out if a polynomial has a root.</li>
</ol>
<p>The algorithm we described will <em>accept</em> any polynomial that
has a root. But it doesn’t reject polynomials that don’t, instead it
loops forever looking for a root. It wasn’t until 1970 that Hilbert’s
10th problem was solved, when it was proved that there is no Turing
machine that can <em>decide</em> the language of integer multivariable
polynomials with integer roots. We’ll look at other examples of
<strong>undecidable languages</strong> after the midterm.</p>
<h3 id="week-10-notes">Week 10 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Mar 24</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">Review</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Mar 26</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><strong>Midterm 2</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Mar 28</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=185">5.5</a>
- <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=192">5.7</a></td>
<td style="text-align: left;">Universal Turing machines</td>
</tr>
</tbody>
</table>
<h4 id="mon-mar-24">Mon, Mar 24</h4>
<p>Today we reviewed context-free languages for the midterm exam. We
also talked about the <a
href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky hierarchy
of languages</a>.</p>
<h4 id="fri-mar-28">Fri, Mar 28</h4>
<p>Today we introduced <strong>universal Turing machines</strong>. We
used them to consider this language:
<!-- This year, I actually went into some details about how to construct a Universal TM.  We talked about how to encode the transition function on a string if Γ* = {0, 1, |,  □} and Σ = {0, 1}.  The idea is that you arrange all of the possible output transitions in Q x Γ x {L, R} using 3 contiguous sections of the tape, and then the output for state k, and symbol $\sigma$ is located in the $|Γ| k + \sigma$ through |Γ| k + \sigma + |Γ| (k+1) - 1$ cells on the tape. From there, it is easy to describe a TM algorithm that can use reference the transition function on one tape and to edit the input string on another tape. --></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Accept</mtext><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">⟨</mo><mi>M</mi><mo>,</mo><mi>w</mi><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mi>M</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a Turing machine and </mtext><mspace width="0.333em"></mspace></mrow><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a string that </mtext><mspace width="0.333em"></mspace></mrow><mi>M</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> accepts</mtext></mrow><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">\text{Accept} = \{ \langle M, w \rangle : M \text{ is a Turing machine and } w \text{ is a string that } M \text{ accepts}\}.</annotation></semantics></math></p>
<ol type="1">
<li>Explain why Accept is Turing recognizable.</li>
</ol>
<p>Then we gave a diagonalization proof that Accept is not Turing
decidable. Suppose there was a decider for Accept. Then we could make a
table with rows for each Turing machine
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>i</mi></msub><annotation encoding="application/x-tex">M_i</annotation></semantics></math>
and columns every Turing machine encoding
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mi>M</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle M_j\rangle</annotation></semantics></math>
and entries 1 or 0 depending on whether
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>i</mi></msub><annotation encoding="application/x-tex">M_i</annotation></semantics></math>
accepts
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mi>M</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle M_j \rangle</annotation></semantics></math>.</p>
<ol start="2" type="1">
<li><p>What would happen if we created a TM
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
inputs any TM encoding
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>M</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle M \rangle</annotation></semantics></math>
and then does the opposite of what
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
does on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>M</mi><mo>,</mo><mo stretchy="false" form="prefix">⟨</mo><mi>M</mi><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle M, \langle M \rangle \rangle</annotation></semantics></math>.
What would
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
do when you input
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>N</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle N \rangle</annotation></semantics></math>
into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>?</p></li>
<li><p>Why is that a contradiction?</p></li>
</ol>
<p>We finished by observed that there are only a countably infinite
number of possible Turing machines, but there is an uncountable infinite
number of languages, so there must be <em>lots</em> of languages that
are not decidable!<br />
<!--
Today we introduced enumerators.  An **enumerator** for a language $L \subseteq \Sigma^*$ is a Turing machines that computes a function $f: \N \rightarrow L$ that is onto.  We started by proving the following:

<div class="Theorem">
**"Easy" Lemma.** If $L \subseteq \Sigma^*$ is decidable, then there is an enumerator for $L$. 
</div>

To prove this lemma, we came up with the following algorithm. In class I didn't include the `just_started` variable which caused a minor issue in the proof. 

```python
input n
# use a decider function to return the n-th string in the language
s = ""
for i in range(n):
    just_started = True
    while just_started or not decider(s):
        just_started = False
        increment(s)
return s
```

<div class="Theorem">
**"Harder" Theorem.** A language $L \subseteq \Sigma^*$ is recognizable if and only if there is an enumerator for $L$.  
</div>

It was relatively easy to prove the $(\Leftarrow)$ direction as this algorithm demonstrates:

```python
input w
# use an enumerator function to return True if w is in L
n = 0
while not w == enumerater(n):
    n++
return True
```

The other direction is harder to prove.  We sketched a proof at the board, but the important thing to understand is this: Why doesn't the algorithm for the "Easy Lemma" prove the $(\Rightarrow)$ case of the "Harder Theorem"?  
--></p>
<h3 id="week-11-notes">Week 11 Notes</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Mar 31</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=165">5.1</a>-<a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=178">5.3</a></td>
<td style="text-align: left;">The halting problem &amp; Rice’s
theorem</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Apr 2</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=205">6.1</a></td>
<td style="text-align: left;">The running time of algorithms</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Apr 4</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=205">6.1</a></td>
<td style="text-align: left;">The running time of algorithms</td>
</tr>
</tbody>
</table>
<h4 id="mon-mar-31">Mon, Mar 31</h4>
<p>We started by explaining why our proof from last time that the
language Accept is undecidable was a diagonalization argument. Suppose
there were a Turing machine
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
(call it a <strong>decider</strong>) that can decide whether or not any
other TM will accept any string.<br />
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">⟨</mo><mi>M</mi><mo>,</mo><mi>w</mi><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mn>1</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mi>M</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> accepts </mtext><mspace width="0.333em"></mspace></mrow><mi>w</mi><mi>.</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>0</mn></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">otherwise</mtext><mi>.</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">D(\langle M, w \rangle) = \begin{cases} 1 &amp; \text{ if }M \text{ accepts } w. \\
                                          0 &amp; \text{otherwise}. \end{cases}</annotation></semantics></math></p>
<p>Imagine we make a table with columns corresponding to different
Turing machine encodings and rows corresponding to different Turing
machines showing the output of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
on each pair.</p>
<center>
<table class="bordered">
<tr>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mi>M</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle M_1 \rangle</annotation></semantics></math>
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle M_2 \rangle</annotation></semantics></math>
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mi>M</mi><mn>3</mn></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle M_3 \rangle</annotation></semantics></math>
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\ldots</annotation></semantics></math>
</td>
</tr>
<tr>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mn>1</mn></msub><annotation encoding="application/x-tex">M_1</annotation></semantics></math>
</td>
<td>
1
</td>
<td>
0
</td>
<td>
1
</td>
<td>
</td>
</tr>
<tr>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mn>2</mn></msub><annotation encoding="application/x-tex">M_2</annotation></semantics></math>
</td>
<td>
0
</td>
<td>
1
</td>
<td>
0
</td>
<td>
</td>
</tr>
<tr>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mn>3</mn></msub><annotation encoding="application/x-tex">M_3</annotation></semantics></math>
</td>
<td>
0
</td>
<td>
0
</td>
<td>
0
</td>
<td>
</td>
</tr>
<tr>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⋮</mi><annotation encoding="application/x-tex">\vdots</annotation></semantics></math>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</table>
</center>
<p>But what happens if we create a new TM
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
that always returns the opposite of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>?
Why is there a contradiction if we try to look up the diagonal entry
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
is given itself and its encoding string as inputs?</p>
<p>By proving that no TM can decide the language Accept, we get the
following corollary about the <a
href="https://en.wikipedia.org/wiki/Halting_problem">halting
problem</a>.</p>
<div class="Theorem">
<p><strong>Theorem (The Halting Problem is Undecidable).</strong> The
language<br />
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Halt</mtext><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">⟨</mo><mi>M</mi><mo>,</mo><mi>w</mi><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mi>M</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a TM that halts on </mtext><mspace width="0.333em"></mspace></mrow><mi>w</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\text{Halt} = \{ \langle M, w \rangle : M \text{ is a TM that halts on }w \}</annotation></semantics></math></p>
<p>is undecidable.</p>
</div>
<p>We gave a proof by contradiction for this theorem.</p>
<ul>
<li><strong>Question.</strong> Suppose we had a Turing machine
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
that can decide the halting problem. Describe a clever algorithm we
could use with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
to determine whether any other Turing machine
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
accepts any string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>.
Why would that algorithm lead to a contradiction?</li>
</ul>
<!--
Here is the proof:

If Halt were decidable, then we could use the following algorithm to decide if $\langle M, w \rangle \in \text{Accept}$:

1. Check if $\langle M, w \rangle \in \text{Halt}$.
2. If it is, run $M$ on $w$ and accept or reject accordingly. 
3. If not, then reject.  

Since this algorithm would decide the language Accept from last time, but we proved that the language Accept is undecidable, we conclude that Halt must also be undecidable.  
-->
<p>It turns out that not only is the halting problem undecidable, but
lots of other questions about Turing machines are undecidable. A
powerful theorem known as <strong>Rice’s theorem</strong> says that
every nontrivial semantic property of a Turing machine is
undecidable.</p>
<p>Fix an encoding method and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mrow><mi>T</mi><mi>M</mi></mrow></msub><annotation encoding="application/x-tex">L_{TM}</annotation></semantics></math>
be the set of all strings that are encoded Turing machines, i.e.,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi>T</mi><mi>M</mi></mrow></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">⟨</mo><mi>M</mi><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mi>M</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a Turing machine</mtext></mrow><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">L_{TM} = \{ \langle M \rangle : M \text{ is a Turing machine} \}.</annotation></semantics></math>
For any Turing machine
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>,
let
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>M</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>:</mo><mi>M</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> accepts </mtext><mspace width="0.333em"></mspace></mrow><mi>w</mi><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">L(M) = \{w \in \Sigma^* : M \text{ accepts } w \}.</annotation></semantics></math></p>
<div class="Theorem">
<p><strong>Definitions.</strong> A <strong>property</strong> of Turing
machines is a subset
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>⊆</mo><msub><mi>L</mi><mrow><mi>T</mi><mi>M</mi></mrow></msub></mrow><annotation encoding="application/x-tex">P \subseteq L_{TM}</annotation></semantics></math>.
We say that a Turing machine
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
has property
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>M</mi><mo stretchy="false" form="postfix">⟩</mo><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">\langle M \rangle \in P</annotation></semantics></math>.</p>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
is <strong>nontrivial</strong> if both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
and its complement
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>P</mi><mo accent="true">‾</mo></mover><annotation encoding="application/x-tex">\bar{P}</annotation></semantics></math>
in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mrow><mi>T</mi><mi>M</mi></mrow></msub><annotation encoding="application/x-tex">L_{TM}</annotation></semantics></math>
are nonempty sets.</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
is <strong>syntactic</strong> if there exist two Turing machines
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mn>1</mn></msub><annotation encoding="application/x-tex">M_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mn>2</mn></msub><annotation encoding="application/x-tex">M_2</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">L(M_1) = L(M_2)</annotation></semantics></math>,
but only one has property
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
(i.e., the difference between the machines is in the syntax of the
algorithm, not the languages they recognize).</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
is <strong>semantic</strong> if it is not syntatic. So if two Turing
machines recognize the same language, then either they both have
property
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
or they both don’t.<br />
</p></li>
</ul>
</div>
<p>Here are some examples of properties. For each example, determine
whether it is a syntactic or semantic property.</p>
<ol type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">INFINITE</mtext><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">⟨</mo><mi>M</mi><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>M</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is infinite</mtext></mrow><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">\text{INFINITE} = \{\langle M \rangle : L(M) \text{ is infinite} \}.</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">REGULAR</mtext><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">⟨</mo><mi>M</mi><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>M</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a regular language</mtext></mrow><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">\text{REGULAR} = \{\langle M \rangle : L(M) \text{ is a regular language} \}.</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">HAS-THREE-STATES</mtext><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">⟨</mo><mi>M</mi><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mi>M</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> has 3 states</mtext></mrow><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">\text{HAS-THREE-STATES} = \{\langle M \rangle : M \text{ has 3 states} \}.</annotation></semantics></math></li>
</ol>
<div class="Theorem">
<p><strong>Rice’s Theorem.</strong> Every nontrivial semantic property
is undecidable.</p>
</div>
<p>We proved <strong>Rice’s theorem</strong> using a proof by
contradiction (see below). Our book also has a different proof in <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=178">Section
5.3</a> if you are interested.</p>
<p><em>Proof.</em> Suppose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mn>1</mn></msub><annotation encoding="application/x-tex">M_1</annotation></semantics></math>
is a Turing machine with property
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mn>2</mn></msub><annotation encoding="application/x-tex">M_2</annotation></semantics></math>
is a Turing machine that doesn’t have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>.
We can assume without loss of generality that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>⌀</mi></mrow><annotation encoding="application/x-tex">L(M_2) = \varnothing</annotation></semantics></math>.
Then for any Turing machine
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
and string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>,
construct a new Turing machine
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mrow><mi>M</mi><mi>w</mi></mrow></msub><annotation encoding="application/x-tex">T_{Mw}</annotation></semantics></math>
that starts by running
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>
until that halts, then it runs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mn>1</mn></msub><annotation encoding="application/x-tex">M_1</annotation></semantics></math>
on the actual input, returning whatever
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mn>1</mn></msub><annotation encoding="application/x-tex">M_1</annotation></semantics></math>
returns. So
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>T</mi><mrow><mi>M</mi><mi>w</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>M</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mi>M</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> halts on </mtext><mspace width="0.333em"></mspace></mrow><mi>w</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>M</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>⌀</mi></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mi>M</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> doesn’t halt on </mtext><mspace width="0.333em"></mspace></mrow><mi>w</mi><mi>.</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">L(T_{Mw}) = \begin{cases} L(M_1) &amp; \text{ if } M \text{ halts on } w \\
                            L(M_2) = \varnothing &amp; \text{ if } M \text{ doesn&#39;t halt on } w. \end{cases}</annotation></semantics></math>
Therefore
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mrow><mi>M</mi><mi>w</mi></mrow></msub><annotation encoding="application/x-tex">T_{Mw}</annotation></semantics></math>
has property
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
if and only if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
halts on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>.</p>
<ul>
<li><strong>Question.</strong> Why would this lead to a contradiction if
there were a Turing machine that could decide
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>?</li>
</ul>
<h4 id="wed-apr-2">Wed, Apr 2</h4>
<p>Today we introduced <strong>big-O notation</strong> and used it to
talk about running times of algorithms.</p>
<div class="Theorem">
<p><strong>Definition (Big-O notation).</strong> Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>,</mo><mi>g</mi><mo>:</mo><mi>ℕ</mi><mo>→</mo><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>∞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f, g: \mathbb{N}\rightarrow [0, \infty)</annotation></semantics></math>.
We say that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f \in O(g)</annotation></semantics></math>
if there are constants
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>,</mo><msub><mi>n</mi><mn>0</mn></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">C, n_0 &gt; 0</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≤</mo><mi>C</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n) \le C g(n)</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n \ge n_0</annotation></semantics></math>.
So
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(g)</annotation></semantics></math>
is the set of all functions that are eventually bounded by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">C g</annotation></semantics></math>
for some constant
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>
</div>
<p>Note that there are lots of important examples in <a
href="https://introtcs.org/public/lec_10_efficient_alg.html">Barak
Chapter 12</a> of algorithms and their running times.</p>
<ol type="1">
<li>Which is true?
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>3</mn></msup><mo>∈</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(\log n)^3 \in O(n)</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mi>O</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n \in O(\log n)^3</annotation></semantics></math>?
<!-- USEFUL TRICK: REDUCE TO $\log n$ versus $n^{1/6}$ --></li>
</ol>
<p>We proved the following facts about big-O notation:</p>
<div class="Theorem">
<p><strong>Theorem (Only Dominant Terms Matter).</strong> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>ℕ</mi><mo>→</mo><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>∞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f: \mathbb{N}\rightarrow [0,\infty)</annotation></semantics></math>
is a sum of nonnegative functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>f</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">f_1, \ldots, f_k</annotation></semantics></math>,
then there is at least one function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>j</mi></msub><annotation encoding="application/x-tex">f_j</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>f</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(f) = O(f_j)</annotation></semantics></math>.
We call that function a <strong>dominant term</strong> for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>.</p>
</div>
<div class="Theorem">
<p><strong>Theorem (Constants Don’t Matter).</strong> For any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>ℕ</mi><mo>→</mo><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>∞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f: \mathbb{N}\rightarrow [0,\infty)</annotation></semantics></math>
and constant
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c &gt; 0</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>c</mi><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(cf) = O(f)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo>±</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(f \pm c) = O(f)</annotation></semantics></math>.</p>
</div>
<div class="Theorem">
<p><strong>Theorem (Products of Functions).</strong> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>∈</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f_1 \in O(g_1)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>∈</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f_2 \in O(g_2)</annotation></semantics></math>,
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><msub><mi>f</mi><mn>2</mn></msub><mo>∈</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>g</mi><mn>1</mn></msub><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f_1f_2 \in O(g_1 g_2)</annotation></semantics></math>.</p>
</div>
<ol start="2" type="1">
<li>Does the base of an exponential function matter in O-notation? What
about for logarithms?</li>
</ol>
<p>We get this hierarchy of functions:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><munder><mtext mathvariant="normal">logarithms</mtext><mo accent="true">⏟</mo></munder><mtext mathvariant="normal">base doesn’t matter</mtext></munder><mo>≪</mo><munder><munder><mtext mathvariant="normal">polynomials</mtext><mo accent="true">⏟</mo></munder><mtext mathvariant="normal">dominant power matters</mtext></munder><mo>≪</mo><munder><munder><mtext mathvariant="normal">exponentials</mtext><mo accent="true">⏟</mo></munder><mtext mathvariant="normal">base matters</mtext></munder><mo>≪</mo><mtext mathvariant="normal">factorials</mtext></mrow><annotation encoding="application/x-tex">\underbrace{\text{logarithms}}_{\text{base doesn&#39;t matter}} \ll \underbrace{\text{polynomials}}_{\text{dominant power matters}} \ll \underbrace{\text{exponentials}}_{\text{base matters}} \ll \text{factorials}</annotation></semantics></math></p>
<p>We used these ideas to find the dominant term for these
expressions:</p>
<ol start="3" type="1">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>4</mn></msup><mo>+</mo><msup><mi>n</mi><mn>3</mn></msup><mo>log</mo><mi>n</mi><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n^4 + n^3 \log n + (\log n)^5</annotation></semantics></math>.</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>100</mn></msup><mo>+</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">n^{100} + 2^n</annotation></semantics></math>.</p></li>
</ol>
<p>So why do we use big-O notation? It makes it easier to talk about a
lot of formulas. For example, an algorithm that requires
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>3</mn><mo stretchy="true" form="postfix">)</mo></mrow><mfrac displaystyle="true"><mrow><mi>n</mi><mi>!</mi></mrow><mrow><mi>k</mi><mi>!</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>!</mi></mrow></mfrac><mo>+</mo><mn>167</mn></mrow><annotation encoding="application/x-tex">7(n+3) \dfrac{n!}{k!(n-k)!}+167</annotation></semantics></math>
steps can be described simply as being
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^{k+1})</annotation></semantics></math>.</p>
<p><strong>Caution 1.</strong> Big-O notation only gives an upper bound
for how fast functions grow. Functions in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(f)</annotation></semantics></math>
don’t have to grow at the same rate as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>,
they can also grow much slower.</p>
<p><strong>Caution 2.</strong> You should always write the simplest
possible expression inside big-O notation. For example
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>5</mn><msup><mi>n</mi><mn>3</mn></msup><mo>+</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(5n^3 + \log n) = O(n^3)</annotation></semantics></math>,
so just write
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math>.</p>
<p>We finished by talking about how we use big-O notation to describe
the runtime of algorithms. Consider the language
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>n</mi></msup><msup><mi>b</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">L = \{a^n b^n : n \ge 0 \}.</annotation></semantics></math>
Here is a simple algorithm to decide
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>:</p>
<ul>
<li><strong>Simple Algorithm.</strong> Input
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">w \in \{a, b \}^*</annotation></semantics></math>.
<ul>
<li>On each pass (left to right) cross out one
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
and then one
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>.</li>
<li>If there are no letters remaining to cross out, then accept.<br />
</li>
<li>If there you can cross out only one letter, then reject.</li>
</ul></li>
</ul>
<ol start="5" type="1">
<li>Estimate the worst-case number of steps it will take to decide if a
string with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-characters
is in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
with this algorithm. Use big-O notation to express the answer.</li>
</ol>
<h4 id="fri-apr-4">Fri, Apr 4</h4>
<p>We started with this example:</p>
<ol type="1">
<li><p>Find an algorithm that determines whether a binary number is
divisible by 7. Hint: if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
is a positive integer written in binary and you add a zero at the end,
what number do you get? What if you add a 1 at the end. How could you
use this idea to keep track of the remainder modulo 7 as you read a
binary number?</p></li>
<li><p>What is the time complexity of the algorithm above?</p></li>
</ol>
<p>It turns out that the language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>:</mo><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a binary number divisible by </mtext><mspace width="0.333em"></mspace></mrow><mn>7</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{ w \in \{0,1\}^* : w \text{ is a binary number divisible by } 7\}</annotation></semantics></math>
is a regular language. For regular languages, we proved the following
result.</p>
<div class="Theorem">
<p><strong>Theorem.</strong> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>
is regular, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
can be decided in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math>
time.</p>
</div>
<!--
We started with this example:

1. Estimate the time complexity for the TM from [midterm 2 review problem #3](midterm2review.pdf) that decrements a binary string by 1. 

-->
<p>Last time we saw an algorithm that can decide
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>n</mi></msup><msup><mi>b</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{a^n b^n : n \ge 0 \}</annotation></semantics></math>
in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math>
steps using a simple algorithm. There are actually better algorithms
that can decide
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
faster. Here’s one:</p>
<ul>
<li><strong>Improved Algorithm.</strong> Input
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">w \in \{a, b \}^*</annotation></semantics></math>.
<ul>
<li>On each pass (left to right) through
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>,
cross out every other
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
(starting with first), then cross out every other
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
(starting with first).</li>
<li>Reject if you find
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
before you find an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>,
or if the total number of letters is odd.</li>
<li>If all letters have been crossed out, then accept.</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li>What is the time complexity of this new algorithm? Hint: How many
times does it need to pass through a string of length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
(worst case)?</li>
</ol>
<p>You can go even faster with a multi-tape Turing machine.</p>
<ul>
<li><strong>Multi-tape Algorithm.</strong> Input
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">w \in \{a, b \}^*</annotation></semantics></math>.
<ul>
<li>Read the input once left to right.<br />
</li>
<li>Copy each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
to tape 2.<br />
</li>
<li>For each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>,
remove an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
from tape 2.</li>
<li>Accept if tape 2 is empty at the end.</li>
</ul></li>
</ul>
<ol start="4" type="1">
<li>What is the time complexity of this multi-tape algorithm?</li>
</ol>
<div class="Theorem">
<p><strong>Theorem (Multi-tape speedup).</strong> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≥</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">t(n) \ge n</annotation></semantics></math>,
then any multi-tape Turing machine that runs in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">t(n)</annotation></semantics></math>
steps can be simulated by a single-tape Turing machine in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(t(n)^2)</annotation></semantics></math>
steps.</p>
</div>
<div class="Theorem">
<p><strong>Theorem (Nondeterministic speedup).</strong> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≥</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">t(n) \ge n</annotation></semantics></math>,
then any nondeterministic Turing machine that runs in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">t(n)</annotation></semantics></math>
steps can be simulated by a deterministic Turing machine in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><annotation encoding="application/x-tex">2^{O(t(n))}</annotation></semantics></math>
steps, that is, the time complexity is at most
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mi>c</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><annotation encoding="application/x-tex">2^{c t(n)}</annotation></semantics></math>
for some constant
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c&gt;0</annotation></semantics></math>.</p>
</div>
<p>We talked about how to prove the second theorem by considering the
computation tree for a nondeterministic Turing machine. If the NTM runs
in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">t(n)</annotation></semantics></math>,
steps, then a breadth first simulation of the NTM must check an
exponential number of branches
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>b</mi><mrow><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(b^{t(n)})</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
is the maximum number of branches at each step. Each branch requires
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">t(n)</annotation></semantics></math>
steps to simulate, so the total run time of the deterministic TM is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>b</mi><mrow><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(t(n) b^{t(n)})</annotation></semantics></math>
which can be expressed as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><annotation encoding="application/x-tex">2^{O(t(n))}</annotation></semantics></math>.</p>
<h3 id="week-12-notes">Week 12 Notes</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Apr 7</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=207">6.2</a></td>
<td style="text-align: left;">The complexity class P</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Apr 9</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=207">6.2</a></td>
<td style="text-align: left;">The complexity class P</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Apr 11</td>
<td style="text-align: center;"><a
href="https://introtcs.org/public/lec_07_other_models.html#ram-machines-and-nand-ram">B8.1</a></td>
<td style="text-align: left;">RAM machines</td>
</tr>
</tbody>
</table>
<h4 id="mon-apr-7">Mon, Apr 7</h4>
<p>Today we started by talking about <a href="HW/HW9.pdf">problem #4 on
homework 9</a>. We also looked at examples using Rice’s theorem like
problem #3. Then we introduced the following class of languages which
can be decided in polynomial time.</p>
<div class="Theorem">
<p><strong>Definition.</strong> A language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>
is in <strong>class P</strong> (denoted
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∈</mo><mi>𝖯</mi></mrow><annotation encoding="application/x-tex">L \in \mathsf{P}</annotation></semantics></math>)
if there is a Turing machine
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
and a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k \ge 0</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
can decide
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mi>k</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^k)</annotation></semantics></math>
time.</p>
</div>
<ol type="1">
<li>Explain why all regular languages are in class P.</li>
</ol>
<h4 id="wed-apr-9">Wed, Apr 9</h4>
<p>Today we did this in-class workshop to prove that all context-free
languages are in class P.</p>
<ul>
<li><strong>Workshop:</strong> <a href="ChomskyNF.pdf">Context Free
Languages are in P</a></li>
</ul>
<!--
2. If $K, L \subseteq \Sigma^*$ are both in class $P$, then prove that the concatenation $KL$ is in class P. Hint: if $w \in KL$, then there exist $x \in K$ and $y \in L$ such that $w$ is the concatenation $xy$.  So to check if $w \in KL$, you just need to check if $w$ can be decomposed into $xy$ where $x \in K$ and $y \in L$. 
    * If the length of $w$ is $n$, then how many different ways can you decompose $w$ into $xy$? 
    * How long will it take a Turing machine to check all of those decompositions to see if any have $x \in K$ and $y \in L$?  

<div class="Theorem">
**Theorem.** If any of the following types of machines has a polynomial time algorithm to solve a problem, then so do all of the others.

1. Turing machine
2. Multi-tape Turing machine
3. C++ program (or any other general programming language)
</div>
-->
<h4 id="fri-apr-11">Fri, Apr 11</h4>
<p>Today we looked at some examples of languages that are in class P. We
also briefly discussed <strong>random access memory (RAM)
machines</strong> which are sometimes a more convenient model for
discussing time complexity. It turns out that any problem that can be
solved in polynomial time by a RAM machine can also be solved in
polynomial time by a Turing machine. There is more in <a
href="https://introtcs.org/public/lec_07_other_models.html#ram-machines-and-nand-ram">Barak
Chapter 8 about RAM machines</a>.</p>
<ol type="1">
<li><p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>PATH</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">⟨</mo><mi>G</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mi>G</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a directed graph with a path from </mtext><mspace width="0.333em"></mspace></mrow><mi>s</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> to </mtext><mspace width="0.333em"></mspace></mrow><mi>t</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\operatorname{PATH} = \{ \langle G, s, t \rangle : G \text{ is a directed graph with a path from } s \text{ to } t \}</annotation></semantics></math>.
Estimate the time complexity of the following algorithm:</p>
<ul>
<li>Step 1 - Mark s.</li>
<li>Step 2 - Scan edges. For any edge from a marked node to an unmarked
node, mark the second node.</li>
<li>Step 3 - Repeat step 2 until there are no remaining edges from
marked to unmarked nodes.</li>
<li>Step 4 - Accept if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
is marked, otherwise reject.</li>
</ul></li>
<li><p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>,</mo><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">K, L \subseteq \Sigma^*</annotation></semantics></math>
are both in class
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>,
then prove that the concatenation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">KL</annotation></semantics></math>
is in class P. Hint: if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>K</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">w \in KL</annotation></semantics></math>,
then there exist
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">x \in K</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">y \in L</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>
is the concatenation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math>.
So to check if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>K</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">w \in KL</annotation></semantics></math>,
you just need to check if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>
can be decomposed into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">x \in K</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">y \in L</annotation></semantics></math>.</p>
<ul>
<li>If the length of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
then how many different ways can you decompose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>
into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math>?</li>
<li>How long will it take a Turing machine to check all of those
decompositions to see if any have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">x \in K</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">y \in L</annotation></semantics></math>?</li>
</ul></li>
<li><p>Estimate the time complexity of the <a
href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean
algorithm</a> for finding the greatest common divisor of two positive
integers:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gcd(a, b): </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (b <span class="op">!=</span> <span class="dv">0</span>): </span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> b</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> a <span class="op">%</span> b</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> t</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a</span></code></pre></div>
<p>Hint: For every two steps of the while loop, the size of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
will decrease by a factor of at least 2, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
will be strictly smaller than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>.</p></li>
</ol>
<h3 id="week-13-notes">Week 13 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Apr 14</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=210">6.3</a></td>
<td style="text-align: left;">The complexity class NP</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Apr 16</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=221">6.5</a></td>
<td style="text-align: left;">NP-complete languages</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Apr 18</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=221">6.5</a></td>
<td style="text-align: left;">NP-complete languages</td>
</tr>
</tbody>
</table>
<h4 id="mon-apr-14">Mon, Apr 14</h4>
<div class="Theorem">
<p>A <strong>verifier</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
for a language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>
is a Turing machine such that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>:</mo><mi>V</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> accepts </mtext><mspace width="0.333em"></mspace></mrow><mo stretchy="false" form="prefix">⟨</mo><mi>w</mi><mo>,</mo><mi>s</mi><mo stretchy="false" form="postfix">⟩</mo><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> for some string </mtext><mspace width="0.333em"></mspace></mrow><mi>s</mi><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">L = \{w \in \Sigma^* : V \text{ accepts } \langle w, s \rangle \text{ for some string } s \}.</annotation></semantics></math>
The string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
is called the <strong>solution</strong> or <strong>certificate</strong>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>.</p>
</div>
<p>Consider the language COMPOSITE
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>:</mo><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a binary number that is not prime</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">= \{ w \in \{0,1\}^* : w \text{ is a binary number that is not prime}\}</annotation></semantics></math>.
This language is hard to decide, but it is easy to verify that a number
is composite if someone tells you two of its factors. For example
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>850441</mn><mo>=</mo><mn>853</mn><mo>⋅</mo><mn>997</mn></mrow><annotation encoding="application/x-tex">850441 = 853 \cdot 997</annotation></semantics></math>.</p>
<p>It turns out that long multiplying two
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-bit
integers can be done in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math>
time.</p>
<div class="Theorem">
<p>A language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>
is in <strong>class NP</strong> (also known as <strong>polynomial time
verifiable</strong>) if there is a verifier for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
that runs in polynomial time as a function of the length of the input
string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>.
We don’t make any assumptions about the length of the solution string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
or how long it will take to find
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.</p>
</div>
<p>We showed that these languages are both in class NP:</p>
<ol type="1">
<li><p>COMPOSITE
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>:</mo><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a binary number that is not prime</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">= \{ w \in \{0,1\}^* : w \text{ is a binary number that is not prime}\}</annotation></semantics></math>.</p></li>
<li><p>3-CLIQUE
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">⟨</mo><mi>G</mi><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mi>G</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a graph with 3 vertices that are all connected by edges</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">= \{\langle G \rangle : G \text{ is a graph with 3 vertices that are all connected by edges}\}</annotation></semantics></math>.</p></li>
</ol>
<p>We also proved this theorem:</p>
<div class="Theorem">
<p><strong>Theorem.</strong> P
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊆</mo><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math>
NP.</p>
</div>
<ol start="3" type="1">
<li><p>Why doesn’t the following algorithm show that COMPOSITE is in
class P?</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Input: An integer N &gt; 1</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="op">=</span> <span class="dv">2</span> to N<span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (N <span class="op">%</span> k <span class="op">==</span> <span class="dv">0</span>): </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        ACCEPT</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co"># If N has no smaller divisors after the loop, then</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>REJECT</span></code></pre></div></li>
</ol>
<p>We also stated and gave a hand-wavy proof of this result:</p>
<div class="Theorem">
<p><strong>Theorem.</strong> A language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
is in class NP if and only if there is a nondeterministic Turing Machine
that decides
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
in polynomial time.</p>
</div>
<p>Along the way, we mentioned some interesting new results:</p>
<ul>
<li>2019 Harvey &amp; van der Hoeven Multiplication Algorithm
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math>.</li>
<li>2003 Agarwal, Kayal, Saxena (AKS) Primality Test - polynomial time
algorithm.</li>
</ul>
<p>It is still unknown whether P
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≠</mo><annotation encoding="application/x-tex">\ne</annotation></semantics></math>
NP.</p>
<h4 id="wed-apr-16">Wed, Apr 16</h4>
<p>Today we introduced the <strong>Boolean satisfiability
problem</strong> (SAT).</p>
<div class="Theorem">
<p><strong>Definition.</strong> A Boolean function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>n</mi></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\phi:\{0,1\}^n \rightarrow \{0,1\}</annotation></semantics></math>
is <strong>satisfiable</strong> if there is an input
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x \in \{0,1\}^n</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\phi(x) = 1</annotation></semantics></math>.</p>
</div>
<ol type="1">
<li><p>Show that the Boolean function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>x</mi><mo accent="true">‾</mo></mover><mo>∨</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∧</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>∨</mo><mover><mi>z</mi><mo accent="true">‾</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\phi(x,y,z) = (\bar{x} \vee y) \wedge (x \vee \bar{z})</annotation></semantics></math>
is satisfiable.</p></li>
<li><p>Give an example of a Boolean function that is not
satisfiable.</p></li>
</ol>
<p>A <strong>Boolean formula</strong> is a string involving variables
and the logical operators AND
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo><annotation encoding="application/x-tex">\wedge</annotation></semantics></math>),
OR
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∨</mo><annotation encoding="application/x-tex">\vee</annotation></semantics></math>),
and NOT (denoted by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∼</mo><annotation encoding="application/x-tex">\sim</annotation></semantics></math>
or a line on top of a variable). Consider the following language:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>A</mi><mi>T</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">⟨</mo><mi>ϕ</mi><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mi>ϕ</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a satisfiable Boolean formula</mtext></mrow><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">SAT = \{ \langle \phi \rangle : \phi \text{ is a satisfiable Boolean formula} \}.</annotation></semantics></math></p>
<ol start="3" type="1">
<li><p>Prove that SAT is decidable.</p></li>
<li><p>Prove that SAT is in NP.</p></li>
</ol>
<p>It turns out that SAT is actually an <strong>NP-complete</strong>
language, which means that if SAT turns out to be in P, then so does
every NP language! That’s a theorem that we aren’t ready to prove yet,
but one of the key ideas in the proof is to be able to reduce one
problem to another problem in polynomial time.</p>
<div class="Theorem">
<p><strong>Definition.</strong> In a Boolean formula,</p>
<ul>
<li>A <strong>literal</strong> is a variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>i</mi></msub><annotation encoding="application/x-tex">x_i</annotation></semantics></math>
or a negated variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>x</mi><mo accent="true">‾</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\bar{x}_i</annotation></semantics></math>.</li>
<li>A <strong>clause</strong> is an expression formed by combining a
finite collection of literals with the OR operator.</li>
</ul>
<p>A Boolean formula is in <strong>conjunctive normal form</strong>
(CNF) if it consists of a finite number of clauses all connected
together by AND operators.</p>
</div>
<p>For example<br />
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>x</mi><mo accent="true">‾</mo></mover><mo>∨</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∧</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>∨</mo><mover><mi>z</mi><mo accent="true">‾</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\phi = (\bar{x} \vee y) \wedge (x \vee \bar{z})</annotation></semantics></math>
is in CNF.</p>
<p>In logic, a <strong>conjunction</strong> is when two or more
statements are joined with an AND, and a <strong>disjunction</strong> is
when two or more statements are joined with an OR.</p>
<p>An important special case of the SAT problem is the 3-SAT problem,
which only looks at Boolean formulas in CNF where the clauses each
involve only 3 literals (possibly including repeated literals). So a
3-CNF formula would be something like:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>∨</mo><mover><msub><mi>x</mi><mn>2</mn></msub><mo accent="true">‾</mo></mover><mo>∨</mo><msub><mi>x</mi><mn>3</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>∧</mo><mrow><mo stretchy="true" form="prefix">(</mo><mover><msub><mi>x</mi><mn>3</mn></msub><mo accent="true">‾</mo></mover><mo>∨</mo><msub><mi>x</mi><mn>5</mn></msub><mo>∨</mo><msub><mi>x</mi><mn>6</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>∧</mo><mrow><mo stretchy="true" form="prefix">(</mo><mover><msub><mi>x</mi><mn>3</mn></msub><mo accent="true">‾</mo></mover><mo>∨</mo><msub><mi>x</mi><mn>6</mn></msub><mo>∨</mo><mover><msub><mi>x</mi><mn>4</mn></msub><mo accent="true">‾</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>∧</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>4</mn></msub><mo>∨</mo><msub><mi>x</mi><mn>5</mn></msub><mo>∨</mo><msub><mi>x</mi><mn>6</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">(x_1 \vee \bar{x_2} \vee x_3 ) \wedge (\bar{x_3} \vee x_5 \vee x_6 ) \wedge (\bar{x_3} \vee x_6 \vee \bar{x_4}) \wedge (x_4 \vee x_5 \vee x_6 ).</annotation></semantics></math></p>
<p>Instead of using a brute force algorithm to decide 3-SAT, we will
take a different approach and prove that solving the 3-SAT problem is
not much harder than deciding this language:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">CLIQUE</mtext><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">⟨</mo><mi>G</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mi>G</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a graph with a </mtext><mspace width="0.333em"></mspace></mrow><mi>k</mi><mtext mathvariant="normal">-clique</mtext><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">\text{CLIQUE} = \{ \langle G, k \rangle : G \text{ is a graph with a } k\text{-clique} \}.</annotation></semantics></math></p>
<p>In fact, we gave the outline of a proof for the following theorem
(although we didn’t formally define “polynomial time reducible”
yet).</p>
<div class="Theorem">
<p><strong>Theorem.</strong> 3-SAT is polynomial time reducible to
CLIQUE.</p>
</div>
<p>The key to link 3-SAT and CLIQUE is to draw a graph where every
vertex corresponds to a literal in one of the clauses, and we draw edges
according to the following rules:</p>
<ul>
<li>Never draw an edge connecting literals in the same clause.</li>
<li>Always draw an edge connecting literals in different clauses, unless
they are negations of each other.</li>
</ul>
<p>Then, if a Boolean formula in 3-CNF has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-clauses,
then it is satisfiable iff the corresponding graph has a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-clique
(as the following image illustrates):</p>
<center>
<a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#3-satisfiability"><img width = 400 src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Sat_reduced_to_Clique_from_Sipser.svg/280px-Sat_reduced_to_Clique_from_Sipser.svg.png"/></a>
<figcaption>
3-satisfiability
</figcaption>
</center>
<h4 id="fri-apr-18">Fri, Apr 18</h4>
<div class="Theorem">
<p><strong>Definition.</strong> A language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">A \subseteq \Sigma^*</annotation></semantics></math>
is <strong>polynomial time reducible</strong> to another language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">B \subseteq \Sigma^*</annotation></semantics></math>
(denoted
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mo>≤</mo><mi>P</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">A \le_P B</annotation></semantics></math>)
when there is a polynomial time computable function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">f: \Sigma^* \rightarrow \Sigma^*</annotation></semantics></math>
such that for every
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">w \in \Sigma^*</annotation></semantics></math>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>A</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if and only if </mtext><mspace width="0.333em"></mspace></mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>w</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mi>B</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">w \in A \text{ if and only if } f(w) \in B.</annotation></semantics></math></p>
</div>
<p>Last time we proved that we can turn any Boolean formula in
3-conjunctive normal form into a graph
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>,
and that the graph has a k-clique (where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
is the number of clauses in the formula) if and only if the original
formula was in 3-SAT.</p>
<ol type="1">
<li><p>If our formula has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
clauses, then how many vertices does the graph
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>
have?</p></li>
<li><p>What is an upper bound for the number of edges in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>?</p></li>
<li><p>Based on the previous answers, how long will it take an algorithm
to to convert a 3-CNF formula to the graph
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>
and number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>?</p></li>
</ol>
<div class="Theorem">
<p><strong>Definition.</strong> A language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
is <strong>NP-hard</strong> if every
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
in NP is polynomial time reducible to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.
Languages that are both NP and NP-hard are called
<strong>NP-complete</strong>.</p>
</div>
<p>In the early 1970s, researchers in both the USA and Soviet Union were
studying algorithms. Cook (USA) and Levin (USSR) gave the first proof
that some problems are NP-complete.</p>
<div class="Theorem">
<p><strong>Theorem (Cook-Levin).</strong> 3-SAT is NP-complete.</p>
</div>
<p>There are several proofs of this theorem. They are all a bit
technical, but we’ll hopefully take a look at one later. For today we
proved the following result.</p>
<ol start="4" type="1">
<li>Prove that if any NP-complete language is in P, then P = NP.</li>
</ol>
<p>Then we looked at another example of a polynomial time reduction.</p>
<p>Let
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mtext mathvariant="normal">-SAT</mtext><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">⟨</mo><mi>ϕ</mi><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mi>ϕ</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a CNF Boolean formula with at most </mtext><mspace width="0.333em"></mspace></mrow><mi>k</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> literals per clause</mtext></mrow><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">k\text{-SAT} =  \{ \langle \phi \rangle : \phi \text{ is a CNF Boolean formula with at most } k \text{ literals per clause} \}.</annotation></semantics></math></p>
<p>Here is an algorithm to reduce k-SAT to 3-SAT.</p>
<ul>
<li>Loop through the clauses of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϕ</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math>.<br />
</li>
<li>For any clause with more than 3 literals do the following:
<ul>
<li>Replace the last two literals with a new dummy variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mi>i</mi></msub><annotation encoding="application/x-tex">d_i</annotation></semantics></math>.<br />
</li>
<li>Add a new clause with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>d</mi><mi>i</mi></msub><mo accent="true">‾</mo></mover><annotation encoding="application/x-tex">\bar{d_i}</annotation></semantics></math>
and the two literals you removed.<br />
</li>
</ul></li>
<li>Repeat until the clause has just 3 literals.</li>
</ul>
<p>It’s not hard to confirm that at every step, the new clauses will be
satisfiable if and only if the old clauses were. It is also not hard to
verify that this algorithm runs in polynomial time.</p>
<h3 id="week-14-notes">Week 14 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Apr 21</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=221">6.5</a></td>
<td style="text-align: left;">Examples of NP-complete languages</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Apr 23</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">Review</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Apr 25</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><strong>Midterm 3</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">Mon, Apr 28</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">TBA</td>
</tr>
</tbody>
</table>
<p><br> <br> <br> <br> <br> <br> <br> <br></p>
</body>
</html>
