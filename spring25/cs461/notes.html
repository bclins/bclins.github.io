<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Theory of Computing</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://bclins.github.io/mockup.css" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
  :root {
    --header-color: #000; 
    --link-color: #00e; 
  }
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Theory of Computing</h1>
</header>
<h2 id="computer-science-461---spring-2025">Computer Science 461 -
Spring 2025</h2>
<center>
Jump to: <a href="index.html">CS 461 Homepage</a>, <a
href="#week-1-notes">Week 1</a>, <a href="#week-2-notes">Week 2</a>, <a
href="#week-3-notes">Week 3</a>, <a href="#week-4-notes">Week 4</a>, <a
href="#week-5-notes">Week 5</a>, <a href="#week-6-notes">Week 6</a>, <a
href="#week-7-notes">Week 7</a>, <a href="#week-8-notes">Week 8</a>, <a
href="#week-9-notes">Week 9</a>, <a href="#week-10-notes">Week 10</a>,
<a href="#week-11-notes">Week 11</a>, <a href="#week-12-notes">Week
12</a>, <a href="#week-13-notes">Week 13</a>, <a
href="#week-14-notes">Week 14</a>
</center>
<h3 id="week-1-notes">Week 1 Notes</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Jan 13</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=15">1.3</a></td>
<td style="text-align: left;">Proof techniques</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Jan 15</td>
<td style="text-align: center;"><a
href="https://introtcs.org/public/lec_02_representation.html#defining-representations">2.1
- 2.2</a></td>
<td style="text-align: left;">Notation &amp; encodings</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Jan 17</td>
<td style="text-align: center;"><a
href="https://introtcs.org/public/lec_03_computation.html#defining-computation">3.1
- 3.7</a></td>
<td style="text-align: left;">Boolean circuits</td>
</tr>
</tbody>
</table>
<h4 id="mon-jan-13">Mon, Jan 13</h4>
<p>Today we talked about proof techniques, particularly proof by
induction. We looked at these two examples:</p>
<ol type="1">
<li>Prove that if a set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
elements, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>
subsets.</li>
</ol>
<p>The second example had to do with the famous <strong>Tower’s of Hanoi
puzzle</strong>( see <a href="https://youtu.be/SMleU0oeGLg"
class="uri">https://youtu.be/SMleU0oeGLg</a>).</p>
<ol start="2" type="1">
<li>Use induction to prove that it is always possible to move the disks
from one peg to another by moving one disk at a time without breaking
the rules.</li>
</ol>
<p>You can also translate many induction arguments into recursive
algorithms.</p>
<ol start="3" type="1">
<li><p>Write a Python function <code>sublists(A)</code> that inputs a
list <code>A</code> and returns a list containing every sublist of
<code>A</code>.</p>
<details>
<p>We did this in class and we came up with something like this:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a> <span class="kw">def</span> sublists(A):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="bu">len</span>(A) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span> [A]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>     last <span class="op">=</span> A[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     B <span class="op">=</span> A[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>     sublists_without_last <span class="op">=</span> sublists(other_elements)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>     sublists_with_last <span class="op">=</span> [s <span class="op">+</span> [last] <span class="cf">for</span> s <span class="kw">in</span> sublists_without_last]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> sublists_without_last <span class="op">+</span> sublists_with_last</span></code></pre></div>
</details></li>
<li><p>Suppose you have three stack variables (implemented as Python
lists):</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>stack1 <span class="op">=</span> [<span class="dv">10</span> <span class="op">-</span> k <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>)]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>stack2 <span class="op">=</span> []</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>stack3 <span class="op">=</span> []</span></code></pre></div>
<p>Write a function
<code>move_disks(n, start_stack, temp_stack, final_stack)</code> that
recursively moves n disks from the <code>start_stack</code> to the
<code>final stack</code>.</p></li>
</ol>
<h4 id="wed-jan-15">Wed, Jan 15</h4>
<p>Today we reviewed mathematical notation, including some new notation
we will be using. We defined <strong>alphabets</strong> which are sets
of symbols we can use to represent things. The most common alphabet in
computer science is the binary alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\Sigma = \{0, 1\}</annotation></semantics></math>.
We use the notation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Σ</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math>
to denote the set of all possible finite length strings constructed from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>.</p>
<p>A set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
can be <strong>represented</strong> or <strong>encoded</strong> using an
alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
if there is a 1-to-1 function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>:</mo><mi>S</mi><mo>→</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">E: S \rightarrow \Sigma^*</annotation></semantics></math>.</p>
<div class="Theorem">
<p><strong>Theorem.</strong> Any countable set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
can be encoded with a 1-to-1 function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>:</mo><mi>S</mi><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">E:S \rightarrow \{0,1\}^*</annotation></semantics></math>.</p>
</div>
<p>We discussed specific encodings such as how to encode the integers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℤ</mi><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math>
and the rationals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℚ</mi><annotation encoding="application/x-tex">\mathbb{Q}</annotation></semantics></math>.</p>
<ul>
<li><strong>Example:</strong> <a
href="https://upload.wikimedia.org/wikipedia/commons/d/dd/ASCII-Table.svg">ASCII
characters</a></li>
</ul>
<p>We also observed another fact:</p>
<div class="Theorem">
<p><strong>Theorem.</strong> If we can encode a set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>,
then we can encode tuples in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>.</p>
</div>
<p>At the end we considered the set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>∞</mi></msup><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>f</mi><mo>:</mo><mi>f</mi><mo>:</mo><mi>ℕ</mi><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{0,1\}^\infty = \{f : f : \mathbb{N}\rightarrow \{0,1\} \}</annotation></semantics></math>
which you can think of as the set of all infinitely long strings of
zeros and ones. We finished by proving</p>
<div class="Theorem">
<p><strong>Theorem.</strong> There is no one-to-one function from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>∞</mi></msup></mrow><annotation encoding="application/x-tex">\{0,1\}^\infty</annotation></semantics></math>
into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">\{0,1\}^*</annotation></semantics></math>.
<!--*--></p>
</div>
<p>A corollary of this theorem is that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>∞</mi></msup></mrow><annotation encoding="application/x-tex">\{0,1\}^\infty</annotation></semantics></math>
is uncountable.</p>
<h4 id="fri-jan-17">Fri, Jan 17</h4>
<p>We talked about <strong>Boolean circuits</strong> which are formed by
AND, OR, and NOT gates. These can be used to implement any
<strong>Boolean expression</strong> formed by the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>∧</mi><annotation encoding="application/x-tex">\wedge</annotation></semantics></math>
(AND),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>∨</mi><annotation encoding="application/x-tex">\vee</annotation></semantics></math>
(OR), and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>¬</mo><annotation encoding="application/x-tex">\neg</annotation></semantics></math>
(NOT) operators.</p>
<center>
<figure>
<img src="https://imgs.xkcd.com/comics/logic_gates.png"></img>
<figcaption>
<a href="https://xkcd.com/2497/">XKCD 2497</a>
</figcaption>
</figure>
</center>
<ol type="1">
<li><p>Write a Boolean expression that takes three Boolean inputs,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x, y, z</annotation></semantics></math>
and returns <code>true</code> if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x, y, z</annotation></semantics></math>
are all the same, and <code>false</code> otherwise.</p></li>
<li><p>Show that you can construct the function IF x THEN y ELSE z for
any Boolean inputs x, y, z using AND, OR, and NOT gates.</p>
<details>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>∧</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∨</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>¬</mo><mi>x</mi><mo>∧</mo><mi>z</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(x \wedge y) \vee (\neg x \wedge z)</annotation></semantics></math></p>
</details></li>
<li><p>Use mathematical induction (and the previous result) to prove the
following:</p></li>
</ol>
<div class="Theorem">
<p><strong>Theorem.</strong> Every function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>n</mi></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f:\{0,1\}^n \rightarrow \{0,1\}</annotation></semantics></math>
can be represented by a Boolean circuit.</p>
</div>
<p>We say that the Boolean operations
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>∧</mi><annotation encoding="application/x-tex">\wedge</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>∨</mi><annotation encoding="application/x-tex">\vee</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>¬</mo><annotation encoding="application/x-tex">\neg</annotation></semantics></math>)
are a <strong>universal set of operations</strong> since every Boolean
function on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\{0,1\}^n</annotation></semantics></math>
can be constructed using those operations.</p>
<p>We finished by talking about how the NAND operation is universal all
by itself. Using just NAND gates, you can construct any Boolean function
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\{0,1\}^n</annotation></semantics></math>.</p>
<div class="Theorem">
<p><strong>Theorem.</strong> Every function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mi>n</mi></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f:\{0,1\}^n \rightarrow \{0,1\}</annotation></semantics></math>
can be represented using NAND operations.</p>
</div>
<ol start="4" type="1">
<li><p>Show that you can use a NAND gate to implement a NOT
gate.</p></li>
<li><p>Show that you can use two NAND gates to implement an AND
gate.</p></li>
<li><p>Use a truth table to confirm that
<code>(NOT x) NAND (NOT y)</code> is equivalent to
<code>x OR y</code>.</p></li>
</ol>
<h3 id="week-2-notes">Week 2 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Jan 20</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">MLK day, no class</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Jan 22</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">Impossible computer programs</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Jan 24</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=29">2.1</a></td>
<td style="text-align: left;">Intro to finite automata</td>
</tr>
</tbody>
</table>
<h4 id="wed-jan-22">Wed, Jan 22</h4>
<ul>
<li><strong>Slides:</strong> <a href="day4.html">Impossible
programs</a></li>
</ul>
<h4 id="fri-jan-24">Fri, Jan 24</h4>
<p>Last time we saw that some functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f: \{0,1\}^* \rightarrow \{0,1\}</annotation></semantics></math>
cannot be computed by a computer program. We saw two proofs that seemed
very different. One used a cardinality argument and the other used proof
by contradiction to show that the program
<code>check_if_program_returns_one()</code> is impossible. It turns out
that both proofs are actually closely related.</p>
<p>Suppose we make a list of all possible programs on the left column of
an infinite table, with a list of all possible input strings at the top
of the table. The values in the body of the table are the output of each
program on each input (including the possibility that there is no
output). The table might look like this:</p>
<center>
<table class="bordered">
<tr>
<th>
</th>
<th>
Input 1
</th>
<th>
Input 2
</th>
<th>
Input 3
</th>
<th>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\ldots</annotation></semantics></math>
</th>
</tr>
<tr>
<th>
Program 1
</th>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\ldots</annotation></semantics></math>
</td>
</tr>
<tr>
<th>
Program 2
</th>
<td>
0
</td>
<td>
0
</td>
<td>
na
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\ldots</annotation></semantics></math>
</td>
</tr>
<tr>
<th>
Program 3
</th>
<td>
0
</td>
<td>
na
</td>
<td>
1
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\ldots</annotation></semantics></math>
</td>
</tr>
<tr>
<th>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⋮</mi><annotation encoding="application/x-tex">\vdots</annotation></semantics></math>
</th>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⋮</mi><annotation encoding="application/x-tex">\vdots</annotation></semantics></math>
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⋮</mi><annotation encoding="application/x-tex">\vdots</annotation></semantics></math>
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⋮</mi><annotation encoding="application/x-tex">\vdots</annotation></semantics></math>
</td>
<td>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋱</mo><annotation encoding="application/x-tex">\ddots</annotation></semantics></math>
</td>
</tr>
</table>
</center>
<p>We can construct a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f:\{0,1\}^* \rightarrow \{0,1\}</annotation></semantics></math>
that cannot correspond to any program by using the same diagonalization
argument that proves that there are uncountably many infinite binary
sequences. That’s essentially what we did when we tried to construct the
function <code>check_if_program_returns_one()</code> last time. We
created a function <code>reverse_check()</code> that corresponds to
reversing the values on the main diagonal of the table above. So we were
using a <strong>diagonalization</strong> argument, which is the same
argument used to prove that there are uncountably many functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f:\{0,1\}^* \rightarrow \{0,1\}</annotation></semantics></math>.</p>
<p>After that, we introduced finite automata. We started with this
example: An automatic door at a grocery store has sensors on the front
and rear. It opens if the sensor on the front is active. It won’t close
until neither of the sensors are active. You can model this with the
following <strong>state diagram</strong>:</p>
<center>
<img src="AutomaticDoorDFA.png" width = 360></img>
</center>
<p>This is an example of a <strong>finite state machine</strong>, also
known as a <strong>deterministic finite automata (DFA)</strong>.</p>
<div class="Theorem">
<p><strong>Definition.</strong> A <strong>deterministic finite automata
(DFA)</strong> consists of</p>
<ol type="1">
<li>A finite set of <strong>states</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>.</li>
<li>A finite <strong>alphabet</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
of possible input signals.</li>
<li>A <strong>transition function</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi>Σ</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">\delta: Q \times \Sigma \rightarrow Q</annotation></semantics></math>.</li>
<li>An <strong>initial</strong> or <strong>start state</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0 \in Q</annotation></semantics></math>.</li>
<li>A set of <strong>final</strong> or <strong>accepting states</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">F \subseteq Q</annotation></semantics></math>.<br />
</li>
</ol>
</div>
<ol type="1">
<li><p>What are the sets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
for the automatic door example above?</p></li>
<li><p>Make a table showing the values of the transition function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>
for the automatic door.</p></li>
<li><p>An automatic toll booth accepts nickles, dimes, and quarters. The
gate won’t open until it receives 25 cents. Draw a state diagram for the
toll booth. What are the sets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>?</p></li>
<li><p>A combination lock (like the ones at the campus post office) can
be modeled as a finite state machine. What are the states and what are
the input signals?</p></li>
<li><p>Describe a DFA that can compute the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f: \{0,1\}^* \rightarrow \{0,1\}</annotation></semantics></math>
which returns 1 when the input string has an odd number of 1’s and 0
otherwise.</p></li>
</ol>
<h3 id="week-3-notes">Week 3 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Jan 27</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=31">2.2</a>
- <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=39">2.3</a></td>
<td style="text-align: left;">Regular languages</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Jan 29</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=43">2.4</a></td>
<td style="text-align: left;">Nondeterministic finite automata</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Jan 31</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=56">2.6</a></td>
<td style="text-align: left;">NFAs and regular languages</td>
</tr>
</tbody>
</table>
<h4 id="mon-jan-27">Mon, Jan 27</h4>
<p>Today we started with these questions about DFAs:</p>
<ol type="1">
<li>For the DFA shown below:
<center>
<img
src="https://people.hsc.edu/faculty-staff/blins/classes/fall23/coms461/FiniteAutomata1.png" />
</center>
<ol type="a">
<li>What is the transition function?</li>
<li>Describe the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f:\{0,1\}^* \rightarrow \{0,1\}</annotation></semantics></math>
that this DFA computes.</li>
</ol></li>
<li>Draw the state diagram for a DFA that computes whether a binary
string contains 011.</li>
</ol>
<div class="Theorem">
<p><strong>Definition.</strong> For any finite alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>,
a <strong>language</strong> is a subset of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Σ</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math>.
A language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>
is <strong>regular</strong> if there is a DFA
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>:</mo><mi>M</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> accepts </mtext><mspace width="0.333em"></mspace></mrow><mi>w</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{w \in \Sigma^* : M \text{ accepts } w \}</annotation></semantics></math>.</p>
</div>
<p>Conceptually, when we think about a DFA, we understand that it can do
two things:</p>
<ul>
<li>A DFA can compute a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f:\Sigma^* \rightarrow \{0,1\}</annotation></semantics></math>.</li>
<li>A DFA can recognize a language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>.</li>
</ul>
<p>It’s important to understand that these two interpretations of what a
DFA does are equivalent, because there is a simple bijection between the
set of all possible languages (the power set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><msup><mi>Σ</mi><mo>*</mo></msup></msup><annotation encoding="application/x-tex">2^{\Sigma^*}</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Σ</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math>)
and the set of all possible functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f: \Sigma^* \rightarrow \{0,1\}</annotation></semantics></math>.</p>
<ol start="3" type="1">
<li>Construct a bijection from the power set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><msup><mi>Σ</mi><mo>*</mo></msup></msup><annotation encoding="application/x-tex">2^{\Sigma^*}</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>f</mi><mo>:</mo><mi>f</mi><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{f: f: \Sigma^* \rightarrow \{0,1\}\}</annotation></semantics></math>.</li>
</ol>
<p>Our solution ended up involving the <strong>indicator
function</strong> for a set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>,
where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>L</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>w</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mn>1</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mi>w</mi><mo>∈</mo><mi>L</mi><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>0</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> otherwise.</mtext></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f_L(w) = \begin{cases} 1 &amp; \text{ if } w \in L, \\ 0 &amp; \text{ otherwise.} \end{cases}</annotation></semantics></math></p>
<h4 id="wed-jan-29">Wed, Jan 29</h4>
<p>We started by constructing some more examples of DFAs.</p>
<ol type="1">
<li><p>Find a DFA that computes whether a binary string <em>ends
with</em> 011. (This is similar, but not the same as a DFA we
constructed last time).</p></li>
<li><p>How many states would a DFA need if you wanted to check whether a
binary string has a 1 in the third position from the last?</p></li>
</ol>
<p>Then we talked about these properties of regular languages.</p>
<div class="Theorem">
<p><strong>Theorem (Finite languages are regular).</strong> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
is a finite alphabet, then any finite
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊂</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subset \Sigma^*</annotation></semantics></math>
is a regular language.</p>
</div>
<ol start="3" type="1">
<li>How would you prove this? If I give you a finite set of strings
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>,
how could you turn that into a DFA that recognizes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>?</li>
</ol>
<div class="Theorem">
<p><strong>Theorem (Closure properties of regular languages).</strong>
Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">A, B \subseteq \Sigma^*</annotation></semantics></math>
be regular languages. Then</p>
<ul>
<li>The <strong>union</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math>
is a regular language.</li>
<li>The <strong>concatenation</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∘</mo><mi>B</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mi>b</mi><mo>:</mo><mi>a</mi><mo>∈</mo><mi>A</mi><mo>,</mo><mi>b</mi><mo>∈</mo><mi>B</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A \circ B = \{ab : a \in A, b \in B\}</annotation></semantics></math>
is a regular language.<br />
</li>
<li>The <strong>Kleene-star</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>*</mo></msup><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mi>…</mi><msub><mi>a</mi><mi>k</mi></msub><mo>:</mo><mi>k</mi><mo>≥</mo><mn>0</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and each </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>a</mi><mi>i</mi></msub><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A^* = \{a_1 a_2 \ldots a_k : k \ge 0 \text{ and each } a_i \in A \}</annotation></semantics></math>
is a regular language.</li>
</ul>
<p>We say that the set of regular languages over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
is <strong>closed</strong> under the three operations: union,
concatentation, and Kleene-star.</p>
</div>
<ol start="4" type="1">
<li>Suppose that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mtext mathvariant="normal">big</mtext><mo>,</mo><mtext mathvariant="normal">small</mtext><mo>,</mo><mtext mathvariant="normal">pet</mtext><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A = \{ \text{big}, \text{small}, \text{pet} \}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mtext mathvariant="normal">cat</mtext><mo>,</mo><mtext mathvariant="normal">dog</mtext><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">B = \{ \text{cat}, \text{dog} \}</annotation></semantics></math>.
What are the elements of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∘</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \circ B</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>B</mi><mo>*</mo></msup><annotation encoding="application/x-tex">B^*</annotation></semantics></math>?</li>
</ol>
<p>We proved the first part of the theorem above (regular languages are
closed under unions) in class by thinking about how to construct a new
DFA
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
that accepts
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math>
using DFAs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>A</mi></msub><annotation encoding="application/x-tex">M_A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>B</mi></msub><annotation encoding="application/x-tex">M_B</annotation></semantics></math>
that accept
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
respectively. To prove this, we answered these questions:</p>
<ol type="1">
<li><p>If the machine
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
is built by running both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>A</mi></msub><annotation encoding="application/x-tex">M_A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>B</mi></msub><annotation encoding="application/x-tex">M_B</annotation></semantics></math>
simultaneously, what are the possible states of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>?</p></li>
<li><p>What are the initial states for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>?</p></li>
<li><p>What is the transition function for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>?</p></li>
<li><p>What are the accepting states of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>?</p></li>
</ol>
<h4 id="fri-jan-31">Fri, Jan 31</h4>
<ol type="1">
<li><p>We started by asking whether regular languages are closed under
intersections. Can we adapt the proof we gave last time for unions to
intersections?</p>
<details>
<p>Yes, regularly languages are closed under intersections. The proof is
almost exactly the same as the proof for unions, the only difference is
that the DFA to recognize
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∩</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cap B</annotation></semantics></math>
has final states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>A</mi></msub><mo>×</mo><msub><mi>F</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">F_A \times F_B</annotation></semantics></math>
while the DFA to recognize
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math>
has final states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>F</mi><mi>A</mi></msub><mo>×</mo><msub><mi>Q</mi><mi>B</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>∪</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Q</mi><mi>A</mi></msub><mo>×</mo><msub><mi>F</mi><mi>B</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(F_A \times Q_B) \cup (Q_A \times F_B)</annotation></semantics></math>,
that is, any pair of states from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mi>A</mi></msub><mo>×</mo><msub><mi>Q</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">Q_A \times Q_B</annotation></semantics></math>
where at least one of the two is final.</p>
</details></li>
</ol>
<p>To prove that regular languages are closed under concatenation, we
introduced a new idea: <strong>non-deterministic finite automata
(NFAs)</strong>.</p>
<p>We looked at this example:</p>
<center>
<img
src="https://people.hsc.edu/faculty-staff/blins/classes/fall23/coms461/NFA1.png" />
</center>
<p>An NFA can have more than one arrow exiting a state with the same
input. When that happens, the machine splits into multiple copies, one
for each possible next state.</p>
<p>If an NFA enters a state that has exiting arrows labeled with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math>,
then the NFA immediately splits into multiple copies, one where the
current state stays the same, and one where the current state moves
along each branch labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math>.
This can happen several times, if there is a sequence of branches
labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math>.</p>
<p>If there is no arrow leaving a state for a given input signal, that
means that the current copy of the machine is a dead end and it does not
need to be continued.</p>
<p>The NFA accepts a string if any of the parallel computations is in an
accepting state after the string is read. We answered these
questions:</p>
<ol start="2" type="1">
<li><p>Which states are active at each step as we read the input string
01010?</p></li>
<li><p>Does this NFA accept the string 01010?</p></li>
<li><p>Describe the set of all strings in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">\{0,1\}^*</annotation></semantics></math>
<!--*--> that this NFA will accept.</p></li>
</ol>
<p>Here is the technical definition of an NFA.</p>
<div class="Theorem">
<p><strong>Definition.</strong> A <strong>non-deterministic finite
automata (NFA)</strong> consists of</p>
<ol type="1">
<li>A finite set of <strong>states</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>.</li>
<li>A finite <strong>alphabet</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
of possible input signals.</li>
<li>A <strong>transition function</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi>Σ</mi><mo>→</mo><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">\delta: Q \times \Sigma \rightarrow 2^Q</annotation></semantics></math>.</li>
<li>An <strong>initial</strong> or <strong>start state</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0 \in Q</annotation></semantics></math>.</li>
<li>A set of <strong>final</strong> or <strong>accepting states</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">F \subseteq Q</annotation></semantics></math>.<br />
</li>
</ol>
</div>
<p>The only change from the definition of a DFA is that the transition
function for an NFA can return a <em>set of states</em> at each step
(including, possibly, the empty set). Think of these multivalued
transitions as creating multiple branching computations that run in
parallel. If the transition function returns the empty set, that means
that that branch of the parallel computation is a dead end and does not
continue.</p>
<ol start="5" type="1">
<li><p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">A, B \subseteq \Sigma^*</annotation></semantics></math>
be regular languages recognized by DFAs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>A</mi></msub><annotation encoding="application/x-tex">M_A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>B</mi></msub><annotation encoding="application/x-tex">M_B</annotation></semantics></math>
respectively. Describe an NFA that uses the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>A</mi></msub><annotation encoding="application/x-tex">M_A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>B</mi></msub><annotation encoding="application/x-tex">M_B</annotation></semantics></math>
to check if a string is in the union
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math>.
Note that every DFA is an NFA that has a transition function that only
ever returns a single state at a time.</p></li>
<li><p>Describe an NFA that can check whether or not the 3rd to last
digit of a binary string is 1 using fewer states than the DFA we
described last time. Hint: What if the NFA “guesses” every time it sees
a 1 that that might be the third to last entry. What should it’s states
be from that point on?</p></li>
</ol>
<h3 id="week-4-notes">Week 4 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Feb 3</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=49">2.5</a></td>
<td style="text-align: left;">NFAs and DFAs are equivalent</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Feb 5</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=60">2.7</a></td>
<td style="text-align: left;">Regular expressions</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Feb 7</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=68">2.8</a></td>
<td style="text-align: left;">Regular expressions and languages</td>
</tr>
</tbody>
</table>
<h4 id="mon-feb-3">Mon, Feb 3</h4>
<p>Today we continued talking about NFAs. We’ve been following the <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf">textbook
by Meshwari &amp; Smid</a> pretty closely this week, so I recommend
reading skimming <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=56">Section
2.6</a> which is what we covered today.</p>
<!--1. Construct an NFA that accepts a string in $\{0\}^*$ iff the length of the string is a multiple of 2 or 3.  Can you construct a DFA that does the same thing and with the same number of states? -->
<ol type="1">
<li><p>We described an NFA that recognizes the concatentation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math>
of two regular languages by running DFAs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>A</mi></msub><annotation encoding="application/x-tex">M_A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>B</mi></msub><annotation encoding="application/x-tex">M_B</annotation></semantics></math>
in parallel. We answer these questions about the NFA:</p>
<ol type="a">
<li>What are the states of the NFA?</li>
<li>What are the final states of the NFA?</li>
</ol></li>
<li><p>We also described an NFA that recognizes the Kleene star
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>A</mi><mo>*</mo></msup><annotation encoding="application/x-tex">A^*</annotation></semantics></math>
of a regular language. The idea is similar to the previous construction,
but you need a way to accept the empty string (if it isn’t part of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>).</p></li>
</ol>
<p>To complete the proof that regular languages are closed under these
two operations, we need to prove this:</p>
<div class="Theorem">
<p><strong>Theorem (Equivalence of NFAs and DFAs).</strong> If there is
an NFA that recognizes a language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">A \subseteq \Sigma^*</annotation></semantics></math>,
then there is a DFA that also recognizes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p>
</div>
<p>The proof is surprisingly simple. An NFA with states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>,
transition function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi>Σ</mi><mo>→</mo><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">\delta: Q \times \Sigma \rightarrow 2^Q</annotation></semantics></math>
can be turned into a DFA that has states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>Q</mi></msup><annotation encoding="application/x-tex">2^Q</annotation></semantics></math>
and transition function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>2</mn></msub><mo>:</mo><msup><mn>2</mn><mi>Q</mi></msup><mo>×</mo><mi>Σ</mi><mo>→</mo><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">\delta_2: 2^Q \times \Sigma \rightarrow 2^Q</annotation></semantics></math>.</p>
<ol start="3" type="1">
<li><p>Describe specifically what
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>S</mi><mo>,</mo><mi>σ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\delta_2(S, \sigma)</annotation></semantics></math>
returns for any subset
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">S \subseteq Q</annotation></semantics></math>
using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>.</p></li>
<li><p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
denotes the accepting states of the NFA, then what are the corresponding
accepting states of the DFA?</p></li>
<li><p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q \in Q</annotation></semantics></math>
is the initial state of the NFA, what is the initial state of the
DFA?</p></li>
</ol>
<p>We applied the idea of this proof to <a
href="HW/HW3.pdf#page=2">Exercise 5 from Homework 3</a>.</p>
<h4 id="wed-feb-5">Wed, Feb 5</h4>
<p>We introduced <strong>regular expressions</strong> (regex).</p>
<div class="Theorem">
<p><strong>Definition.</strong> A <strong>regular expression</strong>
over an alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>
is a string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math>
with symbols from the extended alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mspace width="0.222em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mspace width="0.222em"></mspace><mo>,</mo><mspace width="0.222em"></mspace><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.222em"></mspace><mo>,</mo><mspace width="0.222em"></mspace><mo>*</mo><mspace width="0.222em"></mspace><mo>,</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\Sigma \cup \{ ~(~ , ~)~ , ~*~ , ~|~ \}</annotation></semantics></math>
that has one of the following forms:</p>
<ol type="1">
<li>A <strong>symbol</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>∈</mo><mi>Σ</mi></mrow><annotation encoding="application/x-tex">e \in \Sigma</annotation></semantics></math>
is a regular expression.</li>
<li>A <strong>concatenation</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e = e_1e_2</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>2</mn></msub><annotation encoding="application/x-tex">e_2</annotation></semantics></math>
are regular expressions.</li>
<li>A <strong>union</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><msub><mi>e</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e = e_1|e_2</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>2</mn></msub><annotation encoding="application/x-tex">e_2</annotation></semantics></math>
are regular expressions.</li>
<li>A <strong>grouping</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">e = (e_1)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
is a regular expression.</li>
<li>A <strong>star</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><msub><mi>e</mi><mn>1</mn></msub><mo>*</mo></mrow><annotation encoding="application/x-tex">e = e_1*</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
is either a single symbol or grouping.</li>
</ol>
<p>We also accept the empty set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⌀</mi><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math>
and the empty string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math>
as regular expressions.</p>
</div>
<p>Regular expressions are used to match sets of strings (i.e.,
languages over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>).</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e_1e_2</annotation></semantics></math>
matches any concatenation of a string matched by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
with a string matched by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>2</mn></msub><annotation encoding="application/x-tex">e_2</annotation></semantics></math>.<br />
</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e_1|e_2</annotation></semantics></math>
matches anything matched by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>2</mn></msub><annotation encoding="application/x-tex">e_2</annotation></semantics></math>.<br />
</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>*</mo></mrow><annotation encoding="application/x-tex">e_1*</annotation></semantics></math>
matches any finite concatenation of strings that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math>
matches (including zero matches).</li>
</ul>
<ol type="1">
<li><p>Describe what the following regular expressions represent:</p>
<ol type="a">
<li><code>(0|1)0*</code></li>
<li><code>Σ*1Σ*</code></li>
<li><code>(0|1)*</code></li>
</ol></li>
<li><p>Write a regular expression that recognizes the base-10 decimal
form of any integer that is a multiple of 5.</p></li>
</ol>
<p>Most programming languages use <a
href="https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions">Perl
compatible regular expressions</a> which have several additional
features to make it easier to work with regular expressions. Here are
some examples we talked about in class.</p>
<center>
<table class="bordered">
<tr>
<th colspan="2">
Special Symbols
</th>
</tr>
<tr>
<td>
<code>\s</code>
</td>
<td>
whitespace (tabs, spaces, etc.)
</td>
</tr>
<tr>
<td>
<code>\w</code>
</td>
<td>
alphanumeric (letters &amp; digits)
</td>
</tr>
<tr>
<td>
<code>\d</code>
</td>
<td>
digits (0-9)
</td>
</tr>
<tr>
<td>
<code>.</code>
</td>
<td>
wildcard matches any single character
</td>
</tr>
<tr>
<td>
<code>\</code>
</td>
<td>
escape (for special characters)
</td>
</tr>
</table>
<table>
<tr>
<td>
<table class="bordered">
<tr>
<th colspan="2">
Extra Operators
</th>
</tr>
<tr>
<td>
<code>(e)+</code>
</td>
<td>
at least one
</td>
</tr>
<tr>
<td>
<code>(e)?</code>
</td>
<td>
maybe one (0 or 1)
</td>
</tr>
</table>
</td>
<td>
<table class="bordered">
<tr>
<th colspan="2">
Square Brackets
</th>
</tr>
<tr>
<td colspan="2">
Can match one or more ranges of characters
</td>
</tr>
<tr>
<td>
<code>[a-z]</code>
</td>
<td>
any lower case letter
</td>
</tr>
<tr>
<td>
<code>[a-zA-Z]</code>
</td>
<td>
any letter
</td>
</tr>
<tr>
<td>
<code>[^a-z]</code>
</td>
<td>
anything except a-z
</td>
</tr>
</table>
</td>
</tr>
</table>
</center>
<p>Here is a simple Python regex example:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">&quot;My pet dog likes to go to the park.&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>expr <span class="op">=</span> <span class="st">&quot;pet\s(dog|cat|bird)&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>match <span class="op">=</span> re.search(expr, s)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(match)</span></code></pre></div>
<ol start="3" type="1">
<li><p>Write a regular expression that would match any e-mail address of
the form <code>name@domain.extension</code>.</p></li>
<li><p>Find a regular expression over the alphabet
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\Sigma = \{0,1\}</annotation></semantics></math>
that matches all strings that start with a 1, end with a 1, and have an
even number of zeros between.</p></li>
</ol>
<p>We stated, but did not prove the following theorem.</p>
<div class="Theorem">
<p><strong>Theorem (Equivalence of regular expressions and regular
languages).</strong> A language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>Σ</mi></mrow><annotation encoding="application/x-tex">A \subseteq \Sigma</annotation></semantics></math>
is regular if and only if there is a regular expression that describes
it.</p>
</div>
<ol start="5" type="1">
<li>Find an NFA that recognizes the same language as the regular
expression <code>(ab|a)*</code>. Use the ideas from the previous classes
about how to build NFAs to find the union, concatenation, and Kleene
star of languages.</li>
</ol>
<h4 id="fri-feb-7">Fri, Feb 7</h4>
<p>Today we talked about the proof of the theorem from last time that
regular languages and regular expressions are equivalent. One direction
is easy: every language described by a regular expression is regular.
This is because we already know that regular languages are closed under
the union, concatenation, and Kleene-star operations and we also know
that any finite set of strings is a regular language.</p>
<p>Therefore, we should be able to solve this example, which we didn’t
have time for on Wednesday.</p>
<ol type="1">
<li>Find an NFA that recognizes the same language as the regular
expression <code>(ab|a)*</code>. Use the ideas from the previous classes
about how to build NFAs to find the union, concatenation, and Kleene
star of languages.</li>
</ol>
<p>To prove the converse, we described an algorithm for converting NFAs
to regular expressions. Note that the Maheshwwari &amp; Smid textbook
describes a different approach to convert an NFA into a regular
expression in <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=68">Section
2.8</a>. Our approach is to use a generalized NFA:</p>
<div class="Theorem">
<p><strong>Definition.</strong> A <strong>generalized non-deterministic
finite automata</strong> (GNFA) is just like an NFA, except for the
following changes:</p>
<ol type="1">
<li><p>There is only one accept state and it is not the start
state.</p></li>
<li><p>No transitions enter the start state or leave the accept
state.</p></li>
<li><p>Transitions can be triggered by input strings that match a regex
(not just single symbols).</p></li>
</ol>
</div>
<p>To finish the proof, we make two observations:</p>
<p>First, you can convert any NFA to a GNFA by adding a special start
state that has an epsilon transition to the original start state and a
new accept state that has an epsilon transition from any old final
state.</p>
<p>Second, if you have a GNFA with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n &gt; 2</annotation></semantics></math>
states, there is an equivalent GNFA with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>
states, because you can remove any state (other than the initial and
final states) and replace incoming/outgoing transitions with transitions
described by a regex.</p>
<p>We did the following example to illustrate.</p>
<ol start="2" type="1">
<li>Let Σ={A,C,G,T}. Convert the following NFA to a GNFA, and then
remove states until there are only 2 (the start and accept states).</li>
</ol>
<center>
<img
src="https://people.hsc.edu/faculty-staff/blins/classes/fall23/coms461/ACGT.png" />
</center>
<!-- NOTE: YOU GET MORE THAN ONE ANSWER WHEN YOU DO THIS, AND IT DEPENDS ON HOW YOU DO IT (MAKE SURE TO INCLUDE ANY PATH THAT LOOPS BACK TO A STATE AS A LOOP! -->
<ol start="3" type="1">
<li>What regular expression is equivalent to the NFA above?</li>
</ol>
<p>We finished by talking about languages which are not regular. One
simple language that is not regular is the following:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>:</mo><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> has an equal number of </mtext><mspace width="0.333em"></mspace></mrow><mn>0</mn><mrow><mtext mathvariant="normal">s and </mtext><mspace width="0.333em"></mspace></mrow><mn>1</mn><mtext mathvariant="normal">s</mtext><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">A = \{w \in \{0,1\}^* : w \text{ has an equal number of } 0 \text{s and } 1 \text{s} \}.</annotation></semantics></math></p>
<!--

-->
<h3 id="week-5-notes">Week 5 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Feb 10</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=75">2.9</a></td>
<td style="text-align: left;">Non-regular languages &amp; the pumping
lemma</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Feb 12</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=75">2.9</a></td>
<td style="text-align: left;">More non-regular languages</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Feb 14</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">Review</td>
</tr>
</tbody>
</table>
<h4 id="mon-feb-10">Mon, Feb 10</h4>
<div class="Theorem">
<p><strong>Theorem (Pumping Lemma).</strong> If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math>
is a regular langauage, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
has a length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p \ge 1</annotation></semantics></math>
(called the <strong>pumping length</strong> of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>)
such that if a string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">w \in L</annotation></semantics></math>
is longer than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>,
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mi>x</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">w = xyz</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">x, y, z \in \Sigma^*</annotation></semantics></math>
are substrings such that</p>
<ol type="1">
<li>The middle part
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
is not the empty string (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>y</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|y| \ge 1</annotation></semantics></math>),</li>
<li>The first two parts have length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>x</mi><mi>y</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>≤</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">|xy| \le p</annotation></semantics></math>,
and</li>
<li>The middle part can be “pumped”, that is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msup><mi>y</mi><mi>n</mi></msup><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">xy^nz \in L</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \ge 0</annotation></semantics></math>.</li>
</ol>
</div>
<p>Here is a picture that helps to understand what is going on. It also
gives a clue about why this theorem is true.</p>
<center>
<img src="https://upload.wikimedia.org/wikipedia/commons/e/e8/Pumping_Lemma_for_regular_languages_diagram.png" width=500></img>
</center>
<p>The proof is really simple. If a finite state machine reads a long
enough string, eventually it has to loop back to the same state twice.
The input signals that caused the machine to take that loop make up the
substring
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
in the theorem.</p>
<p>The pumping lemma is a useful tool to prove that some languages are
not regular. You can use the pumping lemma to give a proof by
contradiction. Be careful, the pumping lemma cannot be used to prove
that a language <em>is</em> regular.</p>
<div class="Theorem">
<p><strong>Steps to prove a language is not regular</strong></p>
<ol type="1">
<li><p>Temporarily assume the language
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
is regular and has pumping length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>.</p></li>
<li><p>Try to construct a string in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
so that:</p>
<ol type="a">
<li>The first part of the string is longer than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>.</li>
<li>No substring inside the first part can be pumped.</li>
</ol></li>
<li><p>If you can’t pump the string, that contradicts the pumping lemma,
so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
can’t be regular.</p></li>
</ol>
</div>
<p>We applied this technique to prove that the following languages are
not regular.</p>
<ol type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>:</mo><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> has an equal number of 0 and 1’s</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{w : w \text{ has an equal number of 0 and 1&#39;s}\}</annotation></semantics></math></li>
</ol>
<!--2. $L = \{ww : w \in \{0,1\}^* \}$ -->
<ol start="2" type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mn>0</mn><msup><mi>n</mi><mn>2</mn></msup></msup><mo>:</mo><mi>n</mi><mo>∈</mo><mi>ℕ</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{0^{n^2} : n \in \mathbb{N}\}</annotation></semantics></math>.</li>
</ol>
<p>Here is a nice <a
href="https://people.hsc.edu/faculty-staff/blins/classes/fall23/coms461/pumpinglemmaproof.png">meme
proof using the pumping lemma from Barak textbook</a>.</p>
<h4 id="wed-feb-12">Wed, Feb 12</h4>
<p>Today we looked at more examples of regular and non-regular
languages.</p>
<ol type="1">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">}</mo><mo>*</mo></msup><mo>:</mo><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> is a palindrome</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{w \in \{0, 1\}^* : w \text{ is a palindrome} \}</annotation></semantics></math>.</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>:</mo><mi>w</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> contains an equal number of </mtext><mspace width="0.333em"></mspace></mrow><mn>01</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><mn>10</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> substrings</mtext></mrow><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{w : w \text{ contains an equal number of } 01 \text{ and } 10 \text{ substrings}\}</annotation></semantics></math>.</p></li>
</ol>
<p>The converse of the pumping lemma is not true. So you can’t use the
pumping lemma to prove that a language is regular. In fact, here is a
language that is non-regular, but every string in the language is
pump-able!</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>i</mi></msup><msup><mi>b</mi><mi>j</mi></msup><msup><mi>c</mi><mi>k</mi></msup><mo>:</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi><mo>≥</mo><mn>0</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and if </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi><mo>=</mo><mn>1</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> then </mtext><mspace width="0.333em"></mspace></mrow><mi>j</mi><mo>=</mo><mi>k</mi><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">L = \{a^i b^j c^k : i, j, k \ge 0 \text{ and if } i = 1 \text{ then } j = k\}.</annotation></semantics></math></p>
<ol start="3" type="1">
<li><p>Explain why there is a pumping number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
(in fact
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p=1</annotation></semantics></math>
works) such that any string
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">w \in L</annotation></semantics></math>
can be “pumped”.</p></li>
<li><p>Despite this, explain why
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
is not a regular language. Hint: if there was a DFA that recognizes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>,
what other DFAs could you construct?</p></li>
</ol>
<p>Many programming languages, including Python &amp; Javascript allow
backreferences to previous groups in a regular expression. A group is a
part of the regular expression inside parentheses. The special symbol
<code>\1</code> refers to anything matched by the first group in the
regular expression. Similarly <code>\2</code> refers back to anything
matched by the second group, and so on. For example: the regular
expression <code>"(\w\w*) \1"</code> would match any repeated word like
“word word” or “dog dog”. <em>I tried to demonstrate this in class, but
I got tripped up because Python requires the regular expression to be
entered as a</em> <a
href="https://docs.python.org/3/library/re.html#:~:text=raw%20string">raw
string</a>.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>regex <span class="op">=</span> <span class="vs">r&quot;(\w\w*) \1&quot;</span> <span class="co"># need the r before the quotes to indicate that this is a raw string</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(re.search(regex, <span class="st">&quot;Did I type the the same word twice?&quot;</span>))</span></code></pre></div>
<ol start="5" type="1">
<li>Explain why regular expressions with backreferences are not really
regular expressions (at least not according to our definition). Show
that they can match non-regular languages.</li>
</ol>
<h4 id="fri-feb-14">Fri, Feb 14</h4>
<p>Today we went over some of the problems from <a
href="HW/HW4.pdf">homework 4</a> and the <a
href="midterm1review.pdf">midterm 1 review problems</a>.</p>
<h3 id="week-6-notes">Week 6 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Feb 17</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><strong>Midterm 1</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Feb 19</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=99">3.1</a>
- <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=102">3.2</a></td>
<td style="text-align: left;">Context-free grammars</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Feb 21</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=108">3.3</a></td>
<td style="text-align: left;">Parsing and parse-trees</td>
</tr>
</tbody>
</table>
<h4 id="wed-feb-19">Wed, Feb 19</h4>
<p>Class canceled because of snow.</p>
<!--
#### Fri, Feb 21

Today we introduced **context-free grammars**.  We started with some simple examples from Wikipedia (<https://en.wikipedia.org/wiki/Context-free_grammar#Examples>) to illustrate the definition.  

1. We found a context free grammar that generates the (non-regular) language
$$L = \{a^n b^n : n \in \N\}.$$

2. We looked at the example of a CFG and used it to identify the parts $(V,\Sigma, R, S)$ in the formal definition.  

    ```perl
    S         →  <subject> <verb>
    <subject> →  <article> <noun>
    <article> →  a | the
    <noun>    →  boy | girl | dog
    <verb>    →  runs | jumps | swims
    ```

3. Find a context-free grammar for the language 
$$L = \{w \in \{a,b\}^* : w \text{ has an equal number of } a\text{'s and } b \text{'s} \}.$$

4. Describe how to generate the string `(a + a) * a` using the context free grammar below:

    ```perl
    <expr>    →  <expr> + <term> | <term>
    <term>    →  <term> * <factor> | <factor>
    <factor>  →  (<expr>) | a
    ```



We finished by looking at this example that gives the idea of how a programming language can be though of as a context-free language.  

* <https://en.wikipedia.org/wiki/File:C_grammar_stmt2_svg.svg>
-->
<!--
#### Wednesday, September 27

Today, we briefly went over the first midterm exam. I talked about the [grading scale](gradingScale.html) and went over some of the problems . 

Today we spent more time discussing context free grammars. We talked about **left derivations** and **right derivations**

We looked at this example: 

$$E \rightarrow ~E+E~ | ~E*E~ | ~(E)~ | ~a~ $$

1. Use this CFG to derive the string $a+a*a$.  Try to use a left derivation.  Then use a right derivation.  

2. Show that that string actually has more than one left derivation.  

A grammar is **ambiguous** if there are strings with more than one left derivation.  If every left-derivation is unique, then the grammar is **unambiguous**. Note that some CFGs have unambiguous grammars, but so do not.  This alternate grammar generates the same language as our first example, but is unambiguous:

```
    <expr>    →  <expr> + <term> | <term>
    <term>    →  <term> * <factor> | <factor>
    <factor>  →  (<expr>) | a
```

We looked at this [ambiguous grammar](ambiguousGrammar.html).

3. Show that the sentence "the girl touches the boy with the flower" has two left derivations and those derivations correspond to two different meanings this sentence can have.  
<!--
Tips on constructing context free grammars:

1. To construct the union of two context-free languages: Use a new start variable with this production rule: $S \rightarrow S_1 | S_2$ where $S_1, S_2$ denote the start variables for the CFG's for $L_1$ and $L_2$ respectively.  From that point on, you just separately apply the rules for those two grammars.

2. It is 

#### Friday, September 29

Today we discussed the **pumping lemma for context-free languages**.  This is a little more complicated than the pumping lemma for regular languages. We drew some pictures of parse trees to give an intuitive explanation for why this new pumping lemma is true (see [page 126 in Maheshwari & Smid](https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=134)). In particular, we looked at how the string `a+a*a` gets generated by the grammar:

```
    E →  E + T | T
    T →  T * F | F
    F →  (E) | a
```

In the parse tree, there is a branch where the variable `T` gets repeated, and that lets us "pump".  

We used the pumping lemma to prove that the following languages are not context-free:

1. $L = \{a^n b^n c^n : n \in \N\}$.

1. $L = \{a^{n^2} : n \in \N\}$.

1. $L = \{w = w : w \in \{a, b\}^* \}$.

We also talked about how there are always an uncountable number of languages over a finite alphabet $\Sigma$ (since the set of languages is the power set of $\Sigma^*$), and a computer can only compute a countable set of languages, so it is not surprising that most languages are not context-free.  

--->
<h3 id="week-7-notes">Week 7 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Feb 24</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=132">3.8</a></td>
<td style="text-align: left;">The pumping lemma for CFGs</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Feb 26</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=120">3.5</a>
- <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=124">3.6</a></td>
<td style="text-align: left;">Pushdown automata</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Feb 28</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=128">3.7</a></td>
<td style="text-align: left;">Pushdown automata &amp; context-free
grammars</td>
</tr>
</tbody>
</table>
<h3 id="week-8-notes">Week 8 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Mar 3</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=145">4.1</a>
- <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=149">4.2</a></td>
<td style="text-align: left;">Definition of Turing machines</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Mar 5</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=149">4.2</a></td>
<td style="text-align: left;">Turing computable functions</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Mar 7</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=156">4.3</a>
- <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=159">4.4</a></td>
<td style="text-align: left;">Church-Turing thesis</td>
</tr>
</tbody>
</table>
<h3 id="week-9-notes">Week 9 Notes</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 16%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Mar 17</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=185">5.5</a>
- <a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=192">5.7</a></td>
<td style="text-align: left;">Enumerators</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Mar 19</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">Universal Turing machines</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Mar 21</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=165">5.1</a>-<a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=178">5.3</a></td>
<td style="text-align: left;">The halting problem &amp; Rice’s
theorem</td>
</tr>
</tbody>
</table>
<h3 id="week-10-notes">Week 10 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Mar 24</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">Review</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Mar 26</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><strong>Midterm 2</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Mar 28</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=205">6.1</a></td>
<td style="text-align: left;">The running time of algorithms</td>
</tr>
</tbody>
</table>
<h3 id="week-11-notes">Week 11 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Mar 31</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=207">6.2</a></td>
<td style="text-align: left;">The complexity class P</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Apr 2</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=207">6.2</a></td>
<td style="text-align: left;">The complexity class P - con’d</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Apr 4</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=210">6.3</a></td>
<td style="text-align: left;">The complexity class NP</td>
</tr>
</tbody>
</table>
<h3 id="week-12-notes">Week 12 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Apr 7</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=219">6.4</a></td>
<td style="text-align: left;">Nondeterministic TMs</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Apr 9</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=221">6.5</a></td>
<td style="text-align: left;">The SAT problem</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Apr 11</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=221">6.5</a></td>
<td style="text-align: left;">Polynomial time reductions</td>
</tr>
</tbody>
</table>
<h3 id="week-13-notes">Week 13 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Apr 14</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=221">6.5</a></td>
<td style="text-align: left;">Hamilton path problem</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Apr 16</td>
<td style="text-align: center;"><a
href="https://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf#page=221">6.5</a></td>
<td style="text-align: left;">NP-Complete languages</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Apr 18</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h3 id="week-14-notes">Week 14 Notes</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Day</th>
<th style="text-align: center;">Section</th>
<th style="text-align: left;">Topic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Mon, Apr 21</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">Review</td>
</tr>
<tr class="even">
<td style="text-align: center;">Wed, Apr 23</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><strong>Midterm 3</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fri, Apr 25</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">TBA</td>
</tr>
<tr class="even">
<td style="text-align: center;">Mon, Apr 28</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">TBA</td>
</tr>
</tbody>
</table>
<p><br> <br> <br> <br> <br> <br> <br> <br></p>
</body>
</html>
